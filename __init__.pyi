from typing import List, Dict, Tuple, Any, TypeVar, Generic
import event, math, network, random

# Engine Utils:

def getGlobalDict() -> dict: ... # This dictionary is persistent during the entire gameplay

def hasEditor() -> bool: ... # Returns True if cave is in Editor mode, False if it's a standalone game!
def isPlaying() -> bool: ... # Returns True if the game is currently being played in the editor. It's always true on standalone.

def getGamePath(localPath: str) -> str: ... # Returns the Game's current path + the localPath

def getDeltaTime() -> float: ...
def getFPS() -> float: ...

def getMousePosition(normalize: bool= False) -> Vector2: ...
def getMousePositionUI() -> Vector2: ... # This one takes the Editor UI into account and is always like the UI Elements!
def setMousePosition(x: int, y: int) -> None: ...

def getWindowSize() -> Vector2: ...

def quitGame() -> None: ...

def setScene(name: str) -> bool: ...
def getScene() -> Scene: ...
def getCurrentScene() -> Scene: ...
def restartCurrentScene() -> None: ...

def getEvents() -> Events: ...
def getWindow() -> Window: ...

def getScriptSource(scriptName: str) -> str: ...

def getEntityTemplate(name: str, markAsDirty: bool= False) -> EntityTemplate: ...
def getMesh(name: str, markAsDirty: bool= False) -> Mesh: ...

def playSound(name: str, volume: float = 1.0, loop: int = 0, startPaused: bool = False) -> AudioTrackInstance: ...

def makeImage(filePath: str, pixels: list[int], width: int, height: int) -> bool: ...

T = TypeVar("T")

class AssetHandler(IAssetHandler, Generic[T]):
	def __init__(self, name: str = ""): ...
	def makeWeakRef(asset: T) -> None: ...
	def makeLocalCopy() -> None: ...
	def makeLocalNew() -> None: ...

	def get(markAsDirty: bool = True) -> T: ...


# Math Classes:

class Matrix3:
	def __init__(self): ...

class Matrix4:
	def __init__(self): ...

class IntVector2:
	# [x,y] or [s,t] or [u,v] are equivalents!
	x : int = 0
	y : int = 0

	s : int = 0
	t : int = 0

	u : int = 0
	v : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int): ...
	def __init__(self, other: IntVector2): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector2: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: IntVector2) -> bool: ...
	def __iadd__(self, other: IntVector2) -> IntVector2: ...
	def __isub__(self, other: IntVector2) -> IntVector2: ...
	def __imul__(self, scalar: float) -> IntVector2: ...
	def __idiv__(self, scalar: float) -> IntVector2: ...
	def __add__(self, other: IntVector2) -> IntVector2: ...
	def __sub__(self, other: IntVector2) -> IntVector2: ...
	def __mul__(self, scalar: float) -> IntVector2: ...
	def __truediv__(self, scalar: float) -> IntVector2: ...

class IntVector3:
	# [x,y,z] or [r,g,b] are equivalents!
	x : int = 0
	y : int = 0
	z : int = 0

	r : int = 0
	g : int = 0
	b : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int, z: int): ...
	def __init__(self, other: IntVector3): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector3: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __getitem__(self, key: int) -> int: ...
	def __setitem__(self, key: int, value: int): ...

	def __eq__(self, other: IntVector3) -> bool: ...
	def __iadd__(self, other: IntVector3) -> IntVector3: ...
	def __isub__(self, other: IntVector3) -> IntVector3: ...
	def __imul__(self, scalar: float) -> IntVector3: ...
	def __idiv__(self, scalar: float) -> IntVector3: ...
	def __add__(self, other: IntVector3) -> IntVector3: ...
	def __sub__(self, other: IntVector3) -> IntVector3: ...
	def __mul__(self, scalar: float) -> IntVector3: ...
	def __truediv__(self, scalar: float) -> IntVector3: ...

class Vector2:
	# [x,y] or [s,t] or [u,v] are equivalents!
	x : float = 0
	y : float = 0

	s : float = 0
	t : float = 0

	u : float = 0
	v : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float): ...
	def __init__(self, other: Vector2): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector2: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector2: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector2, value: float) -> Vector2: ...
	def lerpEase(self, other: Vector2, value: float) -> Vector2: ...
	def dot(self, other: Vector2) -> Vector2: ...
	def project(self, intoOther: Vector2) -> Vector2: ...
	
	def __neg__(self) -> Vector2: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __getitem__(self, key: int) -> float: ...
	def __setitem__(self, key: int, value: float): ...

	def __eq__(self, other: Vector2) -> bool: ...
	def __iadd__(self, other: Vector2) -> Vector2: ...
	def __isub__(self, other: Vector2) -> Vector2: ...
	def __imul__(self, scalar: float) -> Vector2: ...
	def __idiv__(self, scalar: float) -> Vector2: ...
	def __add__(self, other: Vector2) -> Vector2: ...
	def __sub__(self, other: Vector2) -> Vector2: ...
	def __mul__(self, scalar: float) -> Vector2: ...
	def __truediv__(self, scalar: float) -> Vector2: ...

class Vector3:
	# [x,y,z] or [r,g,b] are equivalents!
	x : float = 0
	y : float = 0
	z : float = 0

	r : float = 0
	g : float = 0
	b : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float): ...
	def __init__(self, other: Vector3): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector3: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector3: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector3, value: float) -> Vector3: ...
	def lerpEase(self, other: Vector3, value: float) -> Vector3: ...
	def dot(self, other: Vector3) -> Vector3: ...
	def project(self, intoOther: Vector3) -> Vector3: ...
	def cross(self, intoOther: Vector3) -> Vector3: ...
	
	def __neg__(self) -> Vector3: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __getitem__(self, key: int) -> float: ...
	def __setitem__(self, key: int, value: float): ...

	def __eq__(self, other: Vector3) -> bool: ...
	def __iadd__(self, other: Vector3) -> Vector3: ...
	def __isub__(self, other: Vector3) -> Vector3: ...
	def __imul__(self, scalar: float) -> Vector3: ...
	def __idiv__(self, scalar: float) -> Vector3: ...
	def __add__(self, other: Vector3) -> Vector3: ...
	def __sub__(self, other: Vector3) -> Vector3: ...
	def __mul__(self, scalar: float) -> Vector3: ...
	def __truediv__(self, scalar: float) -> Vector3: ...

class Vector4:
	# [x,y,z,w] or [r,g,b,a] are equivalents!
	x : float = 0
	y : float = 0
	z : float = 0
	w : float = 0

	r : float = 0
	g : float = 0
	b : float = 0
	a : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float, w: float): ...
	def __init__(self, other: Vector4): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector4: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector4: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector4, value: float) -> Vector4: ...
	def lerpEase(self, other: Vector4, value: float) -> Vector4: ...
	def dot(self, other: Vector4) -> Vector4: ...
	def project(self, intoOther: Vector4) -> Vector4: ...
	
	def __neg__(self) -> Vector4: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __getitem__(self, key: int) -> float: ...
	def __setitem__(self, key: int, value: float): ...

	def __eq__(self, other: Vector4) -> bool: ...
	def __iadd__(self, other: Vector4) -> Vector4: ...
	def __isub__(self, other: Vector4) -> Vector4: ...
	def __imul__(self, scalar: float) -> Vector4: ...
	def __idiv__(self, scalar: float) -> Vector4: ...
	def __add__(self, other: Vector4) -> Vector4: ...
	def __sub__(self, other: Vector4) -> Vector4: ...
	def __mul__(self, scalar: float) -> Vector4: ...
	def __truediv__(self, scalar: float) -> Vector4: ...

class IntVector4:
	# [x,y,z,w] or [r,g,b,a] are equivalents!
	x : int = 0
	y : int = 0
	z : int = 0
	w : int = 0

	r : int = 0
	g : int = 0
	b : int = 0
	a : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int, z: int, w: int): ...
	def __init__(self, other: IntVector4): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector4: ...

	def __getitem__(self, key: int) -> int: ...
	def __setitem__(self, key: int, value: int): ...

class Quaternion:
	x : float = 0
	y : float = 0
	z : float = 0
	w : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float, w: float): ...
	def __init__(self, other: Quaternion): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Quaternion: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Quaternion: ...
	def length(self) -> float: ...

	def lerp(self, other: Quaternion, value: float) -> Quaternion: ...
	def lerpEase(self, other: Quaternion, value: float) -> Quaternion: ...
	def slerp(self, other: Quaternion, value: float) -> Quaternion: ...
	def inversed(self) -> Quaternion: ...
	
	def __neg__(self) -> Quaternion: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, +, -, *

	def __eq__(self, other: Quaternion) -> bool: ...
	def __iadd__(self, other: Quaternion) -> Quaternion: ...
	def __isub__(self, other: Quaternion) -> Quaternion: ...
	def __imul__(self, scalar: float) -> Quaternion: ...
	def __add__(self, other: Quaternion) -> Quaternion: ...
	def __sub__(self, other: Quaternion) -> Quaternion: ...
	def __mul__(self, scalar: float) -> Quaternion: ...

# A collection of general purpose Utility functions and helpers.

def openWebLink(URL: str) -> None: ... # Opens the given URL in the user's default web browser.
def openApp(executablePath: str) -> bool: ... # Executes a new Standalone and Independent Application given its path. This Application doesn't need to be related to Cave.
def copyToClipboard(text: str) -> None: ... # Given a Text, copies it to the OS Clipboard.
def getCurrentStackTrackBack() -> str: ... 
def getTotalSystemRAM() -> int: ... 
def getRegexMatches(pattern: str, source: str) -> List[utils.RegexMatch]: ... # Returns a list with all Regex matches in the source string, given the Regex pattern.
def isValidFilePath(path: str, fullPath: bool = True) -> bool: ... # Returns True if all characters in the 'path' string are valid characters that can be used as a System filepath. If not fullPath, it will return False if it has '\' or '/'.
def getInvalidFilePathChar(path: str, fullPath: bool = True) -> int: ... # Returns the index of the first invalid character found in the path string or npos if none.
def newEmptyEntity() -> Entity: ... # Helper function to create a new Empty Entity (meaning an Entity with a Transform). It does not add it to anything and it's up to you to handle it.
def newMeshEntity(mesh: str = "Default Cube") -> Entity: ... # Helper function to create a new Mesh Entity (meaning an Entity with a Transform + Mesh Component) and will set the Mesh to the one you pass as a parameter. It does not add it to anything and it's up to you to handle it.
def newLightEntity() -> Entity: ... # Helper function to create a new Light Entity (meaning an Entity with a Transform + Light Component). It does not add it to anything and it's up to you to handle it.
def renderSceneMockFor(entity: Entity, resolution: IntVector2) -> Texture: ... 
def importDefaultAssets() -> None: ... # Imports all the Default Assets (the ones you see when you create a new Project, such as the Default Cube, Material, etc) into the Project.
def reimportDefaultMeshes() -> None: ... # Imports again all the default Meshes.
def showNewAssetMenu() -> Asset: ... # Internal Usage.
def showNewEntityPopup(popupName: str) -> Entity: ... # Internal Usage.
def newEntityPopup() -> Entity: ... # Internal Usage.
def showNewComponentPopup(popupName: str) -> str: ... # Internal Usage.
def newScript(componentName: str) -> str: ... # Creates a new Script (string) with the default new Script text (with the Component definition, etc) and sets the component name to the one you provide as a parameter. Returns the result as a string.
def newScriptDebugTab(tabName: str) -> str: ... # Same as the newScript, except that it will create the default DebugTab code instead of the Component one.
def addMesh(name: str, addToFiles: bool = True) -> Mesh: ... # Creates a new Mesh Asset and adds it to the Engine's Asset Data Subsystem. Returns the newly created Mesh.
def addTexture(name: str, localPath: str, addToFiles: bool = True) -> ImageTexture: ... # Creates a new ImageTexture Asset and adds it to the Engine's Asset Data Subsystem. Returns the newly created ImageTexture.
def addMaterial(name: str, addToFiles: bool = True) -> Material: ... # Creates a new Material Asset and adds it to the Engine's Asset Data Subsystem. Returns the newly created Material.
def endsWith(fullString: str, ending: str) -> bool: ... # Returns true if the given string ends with the provided 'ending'.
def endsWith(fullString: str, endings: List[str]) -> bool: ... # Returns true if the given string ends with one of the the provided 'endings' in the list.
def getFileName(fullPath: str, skipExtension: bool = False) -> str: ... # Given a full path, extracts the filename.
def getCurrentTimeInfo() -> str: ... 
def findInString(source: str, filter: str, caseSensitive: bool = False) -> bool: ... 
def startsWith(source: str, prefix: str) -> bool: ... # Returns true if the given string starts with the provided 'prefix'.
def findAndReplace(source: str, oldSubstr: str, newSubstr: str) -> str: ... 
def toTitleCase(variableName: str) -> str: ... 
def splitLines(text: str) -> List[str]: ... 
def formatBytes(bytes: int) -> str: ... # Givem a number of bytes, formats it as a String with the appropriate (and best match) measurements: B, KiB, MiB, GiB, TiB.
def formatInteger(number: int) -> str: ... # Formats the given integer number as a string, adding dots after each 3 characters (right to left).
def formatInteger(number: int) -> str: ... # Formats the given integer number as a string, adding dots after each 3 characters (right to left).
def formatFloat(number: float, fDigits: int = 2) -> str: ... # Formats the given float number as a string, only keeping the specified number of digits of the fraction (and discarding the rest).
def formatTimeNs(timeNs: int) -> str: ... # Formats a given time in Ns to ms, only keeping two digits of the fraction.

class RegexMatch():
	"""
	Container to describe one Regex Match and its groups.
	"""

	value: str # Raw value of the entire Match.
	groups: List[str] # List of all groups matched in the Raw value.



# Camera related Classes.
class Camera(Transform):
	"""
	The main Camera class. Every scene have its own camera instance. Please notice that this is NOT the same as the Camera Component. You can get the Scene's camera by calling the Scene's getCamera() method.
	"""


	# Enum: CameraCameraType:# "Camera" class Enumeration.
	PERSPECTIVE : int # Perspective Camera
	ORTHOGRAPHIC : int # Orthographic Camera

	renderMask: BitMask 
	exposure: CameraExposure 
	gamma: float 
	useCustomTransform: bool 
	aperture: float # DEPRECATED. Aperture is Unused, use HDR exposure instead.
	nearPlane: float 
	farPlane: float 
	def __init__(self): ... 
	def getMatrix(self) -> Matrix4: ... 
	def getViewProjection(self) -> Matrix4: ... 
	def getProjection(self) -> Matrix4: ... 
	def getProjection(self, customAspect: float) -> Matrix4: ... 
	def getProjectionType(self) -> Camera.CameraType: ... 
	def getScreenRay(self, x: float, y: float) -> Vector3: ... # Given a 2D, camera space, position, returns a 3D vector representing the direction from the camera to that position in the world. NOTE: this is NOT a RayCast by itself!
	def getScreenPos(self, worldPos: Vector3) -> Vector2: ... # Given a World Position, returns its projected 2D position in the Camera Space.
	def getUIPos(self, worldPos: Vector3, clampOutOfBounds: float = - 1 f) -> Vector3: ... # Given a Position in the 3D World, calculates its 2D, UI Element position and returns it to you in the first two dimensions of the output vector (x and y). If the position is BEHIND the camera, the last dimension (Z) will be negative, otherwise, positive. The absolute Z value is also the distance from the worldPos to the Camera. If you pass a positive (from 0.1 to 0.5) value as the clampOutOfBounds parameter, it will clamp the (x, y)  to [-clampOutOfBounds, clampOutOfBounds].
	def isVisible(self, worldPos: Vector3) -> bool: ... # Returns true if the given worldPos is withing the Camera's Frustum
	def setPerspective(self, fieldOfView: float) -> None: ... # Field of View in Degrees
	def setOrthographic(self, orthoArea: float) -> None: ... 
	def getPerspectiveFov(self) -> float: ... 
	def getOrphographicArea(self) -> float: ... 
	def setDistances(self, start: float, end: float) -> None: ... 
	def getAperture(self) -> float: ... # DEPRECATED. Aperture is Unused, use HDR exposure instead.
	def setAperture(self, value: float) -> None: ... # DEPRECATED. Aperture is Unused, use HDR exposure instead.
	def getNearPlane(self) -> float: ... 
	def setNearPlane(self, value: float) -> None: ... 
	def getFarPlane(self) -> float: ... 
	def setFarPlane(self, value: float) -> None: ... 
	def isPerspective(self) -> bool: ... 
	def isOrthographic(self) -> bool: ... 


class CameraExposure():
	eyeAdaptation: bool 
	value: float 
	range: Vector2 
	multiplier: float 
	adjustSpeed: float 



# Cave Engine uses a System of Entities and Components to allow you to build your own game 'Scenes'. You will find bellow the related Component classes to allow this to work.
# 
# Generally, a Component instance belongs to one (and only one) Entity and an Entity can have multiple Components (including multiple components of the same type).
class Component(Asset):
	"""
	Base class for all Cave Engine Components. All methods and variables available here are also available for you to use in your own custom Python Component.
	"""

	entity: Entity # Stores the Entity currently owning this Component. Read only.
	def __init__(self): ... 
	def __init__(self, other: Component): ... 
	def getCustomName(self) -> str: ... 
	def start(self, scene: Scene) -> None: ... # This is called once right after the component's owning Entity gets added and/or activated to a given scene.
	def firstUpdate(self) -> None: ... # Called after all the component's owning Entity other components gets their start methods called. You can use this to late initialize stuff that relies on other component's initializations. It's garanteed that it will always be called after the other component's start and before any updates.
	def update(self) -> None: ... # Called every frame if the scene IS NOT paused.
	def pausedUpdate(self) -> None: ... # Called every frame if the scene IS paused.
	def editorUpdate(self) -> None: ... # This method is meant for debug only. It will be called every frame while in the editor mode, even if the game is not being played. Never gets called on standalone (exported game) mode.
	def lateUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... # This is called once right after the component's owning Entity gets removed and/or deactivated from a given scene.
	def reload(self) -> None: ... # Reloads the Component by calling its end() and then its start() methods. It only works if the Component's Entity already belongs to a Scene. Nothing will happen otherwise.
	def getEntity(self) -> Entity: ... # Returns the Entity currently owning this component. Same as the entity variable.
	def setEntity(self, e: Entity) -> None: ... # Meant for internal Cave use. Changing the owning Entity by this method may cause undefined behaviour.


class EditorComponent(Component):
	"""
	This is a Subclass of the Component class that is meant for you to override (Python) and create Editor Tools that are component level. 

When you add an editor component, it will run like any other Components, except that it will also run while in the Editor (without the game enabled). Its editorUpdate method will also be called. 
If you want to write custom Interfaces for it, override the updateInterface method. To initialize persistent variables, either use the Entity's properties OR create an __init__ method.
	"""

	def __init__(self): ... 
	def __init__(self, other: EditorComponent): ... 
	def updateInterface(self) -> None: ... # Called when the Component's Interface tab is being rendered (Editor). You can safely use cave.ui functions here to draw custom Interfaces.



# Just like we explained in the Component section of the API, Cave Engine uses a System of Entities and Components to allow you to build your own game 'Scenes'.
# 
# Scenes are composed of 0 or more Entities and each Entity can store 0 or more Components. We have some internal 'naming' for specific combinations of Entities and Components, for example: an Entity with no Transform Component is usually called a 'Folder'. If it only have a Transform but no Mesh or Light, it's called an 'Empty' and so on. Please notice that those names are representative only, with no affect on any behaviour.
# 
# An Entity can also store Child Entities (children), which also means that each Entity may or may not have a Parent Entity. If it doesn't, then it's called a Root Entity.
# 
# Child Entities are Added, Moved, Killed (deleted), Activated and/or Deactivated all according to its Parent Entity, recursively.
class Entity(Asset):
	"""
	Cave Engine's Entity class, the main thing that you will use to compose your Scenes. The Entity class is not meant to be extended or manually created via code. Use the proper Scene method for create new Entities instead.
	"""

	templateEntity: AssetHandler[EntityTemplate] # If not None, this Entity inherits from an Entity Template and this was used to build it. Changing this variable alone doesn't immediatelly affect the Entity, unless you Reload it.'
	tags: Tuple[str] # A Set containin non Empty strings that serves as a Tag System. This is faster than Properties because it was implemented in Cave's backends without Python, so you can use this for queries when needed.'
	properties: dict # A customizable Python Dict containing Entity level Properties
	parent: Entity # The Entity's Parent Entity or None if it's a root Entity.
	def __init__(self, name: str = "Entity"): ... 
	def __init__(self, other: Entity): ... 
	def getBoundingBox(self, recursive: bool = True) -> Transform: ... 
	def getAABB(self, recursive: bool = True) -> Tuple[Vector3,Vector3]: ... 
	def isActive(self) -> bool: ... # Returns True if the Entity is Active. It being active means that it is actually being taken into account by the Engine's Systems (such as rendering, logic, physics, etc). A disabled Entity is almost the same as an Entity that 'doesn't exist'.
	def getActive(self) -> bool: ... # Same as isActive()
	def setActive(self, value: bool, scene: Scene) -> None: ... # Sets the Entity's activation state, equivalent to the activate/deactivate methods and that's why it requires the activation Scene.
	def activate(self, scene: Scene) -> None: ... # Activates the Entity in the given Scene.
	def deactivate(self, scene: Scene) -> None: ... # Deactivates the Entity in the given Scene.
	def isTemplated(self, parentRecursive: bool = False) -> bool: ... # Checks if this Entity uses a Template or not. If you set "parentRecursive" to True, it will also recursively check its parents, since an Entity that is a Child of a Templated Scene might also be considered Templated.
	def getRootTemplate(self) -> Entity: ... # Returns None if it's not templated or the Template Asset otherwise.
	def reloadTemplate(self, scene: Scene = None) -> None: ... # Reloads the current Entity's template. You can pass None if the Entity already belongs to a Scene.
	def setParent(self, parent: Entity) -> bool: ... 
	def removeParent(self) -> None: ... 
	def setParentLocal(self, parent: Entity) -> bool: ... 
	def removeParentLocal(self) -> None: ... 
	def getRootParent(self) -> Entity: ... 
	def getParentLevel(self) -> int: ... 
	def canBeAChildOf(self, ent: Entity) -> bool: ... 
	def getParent(self) -> Entity: ... 
	def getChild(self, name: str, recursive: bool = True) -> Entity: ... 
	def getChildren(self) -> List[Entity]: ... 
	def getChildrenRecursive(self) -> List[Entity]: ... 
	def getNumChildren(self) -> int: ... # Returns the number of Children (not recursive) this Entity have.
	def start(self, scene: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getTransform(self) -> TransformComponent: ... # A fast (and cached) alternative to get the main Entity's Transform Component. This is better than using "get(...)" since it's cached.
	def getScene(self) -> Scene: ... 
	def submitTransformToWorld(self) -> None: ... # Due to some important optimizations, changing an Entity's transform doesn't always update its Mesh or Physics rendering location. So if that happens to you, manually call this method after all the transformation changes.
	def add(self, c: Component) -> Component: ... 
	def add(self, cmpName: str) -> Component: ... 
	def get(self, literalName: str, includePython: bool = False) -> Component: ... 
	def get(self, id: int) -> Component: ... 
	def getPy(self, literalName: str) -> Component: ... # Returns the first match in the Components list with this same given name. It will also search for the Python created Components.
	def getAll(self, literalName: str) -> List[Component]: ... 
	def remove(self, cmp: Component) -> None: ... 
	def remove(self, literalName: str) -> None: ... 
	def removeAll(self, literalName: str) -> None: ... 
	def scheduleKill(self, timeInSeconds: float) -> None: ... # Instead of immediately killing the Entity, you may want to schedule for the Entity to automatically kill itself after a given amount of Seconds. Use this method for it.
	def isKillScheduled(self) -> bool: ... # Checks to see if the Entity is scheduled to be Killed.
	def kill(self) -> None: ... # Immediately adds this Entity to the killing queue, meaning that this Entity (and its children) will be completely killed and deleted by the end of the current frame. Due to how Cave works, calling this method won't immediately destroy the entity, so this internal queue is needed. You can use the method 'isAlive()' to check if the Entity is in the queue to be killed this frame or not.
	def reset(self, deleteChildrens: bool = True) -> None: ... 
	def reload(self, recursive: bool = True) -> None: ... 
	def getComponents(self) -> List[Component]: ... 
	def hasTag(self, tag: str) -> bool: ... 
	def addTag(self, tag: str) -> None: ... 
	def removeTag(self, tag: str) -> None: ... 
	def getTags(self) -> List[str]: ... 
	def hasProperty(self, prop: str) -> bool: ... 
	def isAlive(self) -> bool: ... 
	def setEntityUID(self, value: int) -> None: ... # Use this with CAUTION! It will brute force change the Entity ID. It may result into incorrect behaviours. This method is usually used internally.
	def isStatic(self) -> bool: ... 
	def makeStatic(self, recursive: bool = True) -> bool: ... 
	def isDynamic(self) -> bool: ... 
	def makeDynamic(self) -> None: ... 
	def getProperties(self) -> dict: ... 


class EntityMap():
	"""
	Internal Class. The Entity Map is a class instantiated by each Scene to properly store and handle Entities efficiently. You probably don't want to mess with this by hand, since it's an Internal Cave class and the Scene will probably have all the accessors for you do handle the Entities efficiently.
	"""

	deleteEntitiesOnDestructor: bool 
	def __init__(self): ... 
	def drawDebugUI(self) -> None: ... 
	def update(self) -> None: ... 
	def add(self, object: Entity) -> Entity: ... 
	def remove(self, object: Entity) -> None: ... 
	def cancelRemoval(self, entity: Entity) -> None: ... 
	def get(self, id: int) -> Entity: ... 
	def get(self, name: str) -> Entity: ... 
	def getAll(self) -> List[Entity]: ... 
	def getAllRoots(self) -> List[Entity]: ... 
	def getCount(self) -> int: ... 
	def getAddQueue(self) -> List[Entity]: ... 
	def getRemoveQueue(self) -> List[Entity]: ... 
	def getActive(self) -> Entity: ... 
	def setActive(self, e: Entity, setActiveDebugAsset: bool = True) -> None: ... 


class EntityTemplate(Asset):
	def __init__(self): ... 
	def __init__(self, entity: Entity): ... 
	def getBase(self) -> Entity: ... 
	def setBase(self, entity: Entity) -> None: ... 


class Scene(Asset):
	"""
	Main Scene class. This is where all the entities of your Scene are located.
You can get the current scene by calling cave.getCurrentScene().
	"""

	uiCanvas: UICanvas # The Canvas used by the Scene to Draw all the Game UI Elements. You probably don't want to mess with this by hand.
	properties: dict # A customizable Python Dict containing Scene level Properties.
	paused: bool # If you set this to True, the scene will go to its paused state, not calling any Entity's update method. It will call their pausedUpdate.
	allowPlay: bool 
	gravity: Vector3 # The Scene's gravity, used for Dynamic Rigid Body Physics. Note that it does NOT affect characters since they have its own independent gravity.
	postProcessingOverride: str 
	def __init__(self, name: str = "Scene"): ... 
	def isCurrentScene(self) -> bool: ... # Checks if this Scene is the active one.
	def addDefaultObjects(self) -> None: ... # Adds the Default Cave's new Scene Entity layout to this Scene.
	def renderToTexture(self, cam: Camera = None, resolution: IntVector2 = IntVector2(0,0)) -> Texture: ... 
	def newEntity(self) -> Entity: ... # Creates a new Empty Entity.
	def copyEntity(self, e: Entity) -> Entity: ... # Creates a new Entity by Copying an existing one.
	def add(self, e: Entity) -> Entity: ... # Adds an existing Entity to the Scene.
	def remove(self, e: Entity) -> None: ... # Queues an Entity to be removed and deleted from Scene.
	def reloadTemplate(self, templateID: int) -> None: ... 
	def get(self, id: int) -> Entity: ... # Gets an Entity by its ID. Average Time Complexity is O(1), worst case is O(logN).
	def get(self, name: str) -> Entity: ... # Gets and Entity by its Name. Time Complexity is O(N), so avoid using this too much!
	def addFromTemplate(self, templateName: str, position: Vector3 = Vector3(0), rotation: Vector3 = Vector3(0), scale: Vector3 = Vector3(1)) -> Entity: ... # Creates and returns a new Entity built from the given Entity Template.
	def rayCast(self, origin: Vector3, target: Vector3, mask: BitMask = BitMask()) -> RayCastOut: ... 
	def rayCastAll(self, origin: Vector3, target: Vector3, mask: BitMask = BitMask()) -> List[RayCastOut]: ... 
	def sphereCast(self, origin: Vector3, target: Vector3, radius: float, mask: BitMask = BitMask()) -> SphereCastOut: ... 
	def sphereCastAll(self, origin: Vector3, target: Vector3, radius: float, mask: BitMask = BitMask()) -> List[SphereCastOut]: ... 
	def checkContactBox(self, box: Transform, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... # You can use this method to do Collision queries using a Box (defined by the transform you pass).
	def checkContactBox(self, pos: Vector3, rot: Quaternion, scale: Vector3, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... # You can use this method to do Collision queries using a Box (defined by the position, rotation and scale you pass).
	def checkContactSphere(self, pos: Vector3, radius: float, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... # You can use this method to do Collision queries using a Sphere (defined by the position and radius you pass).
	def addDebugLine(self, origin: Vector3, target: Vector3, color: Vector3) -> None: ... # Draws a Debug Line in the 3D Space, from the origin to the target position. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugArrow(self, origin: Vector3, target: Vector3, color: Vector3) -> None: ... # Draws a Debug Arrow in the 3D Space, from the origin to the target position. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugPoint(self, position: Vector3, color: Vector3) -> None: ... # Draws a Debug Point in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugCube(self, transform: Transform, color: Vector3) -> None: ... # Draws a Debug Cube in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugCircle(self, transform: Transform, color: Vector3, numVertices: int = 8) -> None: ... # Draws a Debug Circle in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugCircle(self, position: Vector3, radius: float, color: Vector3, numVertices: int = 8) -> None: ... # Draws a Debug Circle in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugSphere(self, position: Vector3, radius: float, color: Vector3, numVertices: int = 8) -> None: ... # Draws a Debug Sphere in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def getCamera(self) -> Camera: ... # Gets the Scene's camera instance. This is the actual camera used by the Engine to render the Scene.
	def getSunLight(self) -> RenderableSun: ... 
	def getSunLightPtr(self) -> RenderableSun: ... 
	def getBoundingBox(self) -> Transform: ... # Returns the Approximate Bounding Box of the Entire Scene, representing everything that is Visual in it.
	def getBoundingBoxPhysics(self) -> Transform: ... # Returns the Approximate Bounding Box of the Entire Scene, representing the Physics Colliders.
	def getGravity(self) -> Vector3: ... 
	def setGravity(self, gravity: Vector3) -> None: ... 
	def getRenderGraphConfig(self) -> RenderGraph.Config: ... 
	def getPostProcessingOverride(self) -> str: ... 
	def setPostProcessingOverride(self, postProcessing: str) -> None: ... 
	def resetElapsedSceneTime(self) -> None: ... 
	def incrementElapsedSceneTime(self) -> None: ... 
	def getElapsedSceneTime(self) -> float: ... 
	def playTimeline(self, name: str, loop: bool = False, playWhenPaused: bool = False, restoreCameraOnEnd: bool = True) -> None: ... # Plays a specific Timeline (Cutscene) by its Asset name.
	def isTimelineBeingPlayed(self, name: str) -> bool: ... # Checks if a specific Timeline is being played  by its Asset name.
	def isAnyTimelineBeingPlayed(self) -> bool: ... 
	def getNumTimelinesBeingPlayed(self) -> int: ... 
	def stopTimeline(self, name: str) -> None: ... 
	def stopAllTimelines(self) -> None: ... 
	def getTimelineProgress(self, name: str) -> float: ... 
	def getTimelineFrame(self, name: str) -> float: ... 
	def getTimelineLoops(self, name: str) -> int: ... 
	def getEntities(self) -> List[Entity]: ... # Returns all Entities in the Scene.
	def getEntitiesWithTag(self, tag: str) -> List[Entity]: ... # Returns all Entities with this specific Tag. Time Complexity is O(N).
	def getEntitiesWithName(self, name: str) -> List[Entity]: ... # Returns all Entities with this specific Name. Time Complexity is O(N).
	def getEntitiesWithProperty(self, prop: str) -> List[Entity]: ... # Returns all Entities with this specific Property. Time Complexity is O(N). Note: since it uses Python to lookup this information, it may be slower than the Tags.
	def getRootEntities(self) -> List[Entity]: ... # Returns all Entities in the Scene. A Root Entity is an Entity without a Parent.
	def getRootEntitiesWithTag(self, tag: str) -> List[Entity]: ... # Returns all Entities with this specific Tag. Time Complexity is O(N).
	def getRootEntitiesWithProperty(self, prop: str) -> List[Entity]: ... # Returns all Entities with this specific Property. Time Complexity is O(N). Note: since it uses Python to lookup this information, it may be slower than the Tags.
	def getEntitiesFromTemplate(self, templateName: str) -> List[Entity]: ... # Returns all Entities that inherits from a given Entity Template. Time Complexity is O(N).
	def getEntitiesWithComponent(self, componentName: str, searchPythonComponents: bool = False) -> List[Entity]: ... # Returns all Entities that have the given Component. Time Complexity is O(NC) where C is the Component count. Note: this is probably very slow...
	def getEntitiesHandler(self) -> EntityMap: ... 
	def getActiveEntity(self) -> Entity: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def getProperties(self) -> dict: ... 


class Asset():
	"""
	Asset is the main Cave Engine Class. Most Classes inherits from it.
If a class is an Asset, it usually means that it can be Serialized to disk (saved and loaded) by the engine and also be inspected in the Editor.
	"""

	name: str 
	debug: AssetDebug 
	uID: int 
	def getUID(self) -> int: ... 
	def getUniqueName(self) -> str: ... # Unique Name consists in the <Asset Name + ## + UID>
	def getAssetFileName(self) -> str: ... 
	def getAssetTypeName(self) -> str: ... 
	def getThumbnail(self, generateIfNone: bool = True, forceRegenation: bool = False) -> Texture: ... 


class AssetDebug():
	"""
	Debug information for each Asset is usually meant to be used by the Editor only. There is no garantee that those informations will be persistent or serialized.
	"""

	thumbnail: Texture 
	thumbnailFlip: bool 
	dirty: bool # If the Asset is Dirty, it means that it needs to be serialized to Disk (Saved). It usually means that the asset was opened and/or modified by the Editor. Being set to true does not mean guaranteed that it WAS in fact modified, but that it was likely to.
	serializeAsJson: bool 
	handler: AssetFile 
	saveTime: float # How many time, in seconds, this Asset took to Save to Disk. If < 0, it's unknown or not available.
	loadTime: float # How many time, in seconds, this Asset took to Load from Disk. If < 0, it's unknown or not available.
	wasSelected: bool 
	memory: memory.Monitor 


class AssetData():
	mainScene: AssetHandler[Scene] 
	def __init__(self): ... 
	def importRawAsset(self, absPath: str, skipAdvanced: bool = False) -> bool: ... 
	def clear(self, freeMemory: bool = False) -> None: ... 
	def merge(self, data: AssetData, replaceDuplis: bool = False) -> None: ... 
	def getAssetMap(self, classId: int, createIfNone: bool = True) -> AssetMap: ... 
	def getAssetMaps(self) -> List[AssetMap]: ... 
	def get(self, assetId: int) -> Asset: ... 
	def getAssetCount(self) -> int: ... 
	def resetFileSystem(self) -> None: ... 
	def scanAssets(self) -> None: ... 
	def setSelectedFile(self, file: AssetFile, markForRecovery: bool = True) -> None: ... 
	def getSelectedFile(self, rootIfNone: bool = True, attemptToRecover: bool = True) -> AssetFile: ... 
	def getRootFile(self) -> AssetFile: ... 
	def getFileAt(self, path: str, createIfNone: bool = True) -> AssetFile: ... 


class CavePackageDescriptor():
	"""
	As the name suggests, its a Descriptor class used by Cave to store Cave Package specific information, meant to be used when exporting/importing a Package. Internal Use.
	"""

	name: str # The Package name.
	description: str # Description of the Package.
	author: str # Who made the Package.
	date: str # Creation/Export date of the Package.
	thumbnail: AssetHandler[Texture] # An Asset Handler for a Texture to be used as the Package Thumbnail. Note: This will not be saved/loaded as a regular Handler!
	thumbTexture: ImageTexture # A direct pointer to the loaded Thumbnail Texture. This will not be serialized and not freed! (up to you), it's here to store the thumbnail when package is loaded.
	def __init__(self): ... 


class AssetFile(Asset):
	"""
	In Cave, every Asset from the Asset Data, in order to appear in the Asset Browser, have an 1-1 connection to an AssetFile (you can access it from the Asset's debug.handler property).

The AssetFile may not be connected to any Asset as well. In this case, it will be considered a Folder and could have Child Asset Files. Everything you see in the Asset Browser is just Asset Files, including the Assets itself. In this case, the Asset Files are mapped to the actual Assets, as explained.

Asset Files can be Exported as a Cave Package, hence why you'll see the Package Descriptor API near by.
	"""

	selected: bool 
	name: str 
	def __init__(self, name: str = "Folder"): ... 
	def __init__(self, asset: Asset): ... 
	def __init__(self, other: AssetFile): ... 
	def export(self, file: File, desc: CavePackageDescriptor = None, all: bool = True) -> None: ... # Exports the asset (recursively, if it's a folder) into a standalone Cave Package that can be later imported into another project. If the 'all' parameter is True, it will also save the asset datas itself.
	def import(self, file: File, desc: CavePackageDescriptor = None, all: bool = True) -> None: ... 
	def getPath(self) -> str: ... 
	def sortChildren(self) -> None: ... # It will sort the children by name, then by type.
	def agroupChildren(self) -> None: ... # It will organize all the children into folders by type.
	def dissolveFolder(self) -> bool: ... # Will move all the folder content to its parent. Does nothing if this is not a folder or don't have a parent. Returns True on success.
	def drawThumbnail(self, width: float = 128, height: float = 128, generateThumb: bool = True) -> bool: ... # Internal Usage.
	def drawFolderElements(self, zoom: float = 1) -> None: ... # Internal Usage.
	def drawFolderHierarchy(self, name: str = "", icon: str = "") -> None: ... # Internal Usage.
	def drawFolderHeader(self) -> None: ... # Internal Usage.
	def isFolder(self) -> bool: ... # Returns True if this Asset File is a folder (meaning that it could have Child Asset Files and that it is not mapped to an actual Asset).
	def isAsset(self) -> bool: ... # Returns True if this Asset File is mapped to an actual Asset.
	def isDirty(self) -> bool: ... # Returns True if the corresponding Asset (or Folder) needs to be Serialized (Saved).
	def markAsDirty(self) -> None: ... 
	def markAsNotDirty(self) -> None: ... 
	def getParent(self) -> AssetFile: ... 
	def addChild(self, child: AssetFile) -> bool: ... 
	def addChildAsset(self, asset: Asset) -> bool: ... 
	def removeChild(self, child: AssetFile) -> bool: ... 
	def removeEmptyFolders(self) -> None: ... 
	def canBeAChildOf(self, parent: AssetFile) -> bool: ... 
	def getChild(self, name: str) -> AssetFile: ... 
	def getChildRecursive(self, childID: int) -> AssetFile: ... 
	def getChildFolder(self, name: str) -> AssetFile: ... 
	def getChildren(self) -> List[AssetFile]: ... 
	def getChildrenRecursive(self) -> List[AssetFile]: ... 
	def getName(self) -> str: ... 
	def getUniqueAssetFileName(self) -> str: ... 
	def getUniqueAssetFileID(self) -> int: ... 
	def setName(self, value: str) -> None: ... 
	def getAsset(self) -> Asset: ... 
	def isOrphan(self) -> bool: ... 



# Asset Handlers are a very important element of Cave Engine's structures. Usually when you are linking an Asset to another thing, such as the Material, Mesh of the Mesh Component or the Textures of the Materials (for example), you will never store a direct pointer to it. Because if you do, then what would happen if the Asset gets deleted in the Asset Browser? For example if a Material links to a texture for its diffuse color, and then you go ahead and delete this Texture. That would inevitable cause a memory access violation and a Crash.
# 
# That's why you should always use the proper Asset Handlers to deal with this indirection.
# 
# When it comes to in game logic, it's usually **safer** to store direct references to an Asset, since it's very unlikely that you will be deleting or changing Assets in real time.
class IAssetHandler():
	"""
	This is the Base Interface class for each Asset Handler. Specific Asset types (Texture, Material, Mesh, etc) will have their own specific Asset Handler implementation, usually described as 'AssetHandler_T_', where 'T' is the specific Asset Type. You will also find them described in the stubs as `AssetHandler[T]`, just for Python Reference (but this is wrong).
	"""


	# Enum: IAssetHandlerMode:# "IAssetHandler" class Enumeration to define the reference level to the current Asset being referenced by the Handler (if any).
	FROM_ASSET_DATA : int # It means that the Asset is stored within Cave Engine's asset Subsystems (aka it's visible in the Asset Browser).
	FROM_WEAK_REF : int # It means that the Asset has a weak reference, likely a direct pointer to an instance and it will NOT be serialized. Meaning that if you save and load (reload) the project, the reference will be gone.
	FROM_LOCAL : int # It means that the Asset is locally instantiated, managed and garbage collected by this Asset Handler. It is not registered in the internal Engine's Asset Subsystems.
	FROM_ASSET_DATA_WEAK : int # Forces it to use asset name instead of the ID. As soon as an asset is found, it gets promoted to strong asset data.

	name: mutablestr 
	def makeAssetDataWeak(self) -> None: ... 
	def makeAssetDataStrong(self) -> None: ... 
	def setAsset(self, asset: Asset, strong: bool = True) -> None: ... 
	def setAsset(self, name: str, searchChildren: bool = True) -> None: ... # Makes this Handler references an Asset (from Asset Data) by its name.
	def getAssetUID(self) -> int: ... 
	def getAsset(self, markAsDirty: bool = True, searchChildren: bool = False) -> Asset: ... # Returns a pointer to the Given Asset without any cast (so it will reference the Base Asset class). You may want to use the specific 'get()' method from each AssetHandler to retrieve the reference with a proper cast.
# 
# This function can return None if there is no matching asset in the Handler.
	def isLocal(self) -> bool: ... # True if Mode is FROM_LOCAL.
	def isWeakRef(self) -> bool: ... # True if Mode is FROM_WEAK_REF.
	def isFromAssetData(self) -> bool: ... # True if Mode is FROM_ASSET_DATA.
	def saveToAssetData(self, filePath: str = "") -> bool: ... # If the mode is FROM_LOCAL and there is a valid Asset, transfer its ownership to the Engine's Asset Subsystems, effectively adding it to the Asset Browser in the given path. Returns True on success, False on failure (or if the Asset isn't Local).


class AssetImporterFilter():
	createSubfolder: bool 
	generatePhysics: bool 
	filters: Dict[int,bool] 
	def canImport(self, id: int) -> bool: ... 


class AssetImporter():
	data: AssetData 
	def __init__(self, filePath: str): ... 
	def sendToApp(self, globalFilters: AssetImporterFilter = AssetImporterFilter()) -> None: ... 
	def getFilePath(self) -> str: ... 
	def getFileName(self) -> str: ... 
	def isValid(self) -> bool: ... 
	def getFilter(self, asset: Asset) -> bool: ... 
	def isFiltered(self, asset: Asset) -> bool: ... 


class AssetMap():
	def __init__(self, classID: int, ownerData: AssetData): ... 
	def clear(self, freeMemory: bool = False) -> None: ... 
	def get(self, name: str, searchChildren: bool = False) -> Asset: ... 
	def get(self, id: int, searchChildren: bool = False) -> Asset: ... 
	def getAll(self, includeChildren: bool = True) -> List[Asset]: ... 
	def getAll(self, name: str, includeChildren: bool = True) -> List[Asset]: ... 
	def addNewFromUI(self) -> Asset: ... 
	def addCopyFromUI(self, source: Asset) -> Asset: ... 
	def add(self, data: Asset, replaceDuplis: bool = False) -> bool: ... 
	def merge(self, other: AssetMap, replaceDuplis: bool = False) -> None: ... 
	def remove(self, name: str, freeMemory: bool = True) -> bool: ... 
	def remove(self, id: int, freeMemory: bool = True) -> bool: ... 
	def getMapClassID(self) -> int: ... 
	def getAssetCount(self) -> int: ... 
	def getNames(self, includeId: bool = False) -> List[str]: ... 
	def getIDs(self) -> List[int]: ... 


class UniqueID():
	def __init__(self): ... 
	def __init__(self, other: UniqueID): ... 
	def get(self) -> int: ... 
	def set(self, value: int) -> None: ... 
	def __eq__(self, other) -> bool: ... # self == other
	def __ne__(self, other) -> bool: ... # self != other
	def __str__(self) -> str: ...


class AudioDevice():
	def __init__(self, _sampleRate: int = 44100): ... 
	def playTrack(self, audio: AudioTrack, loops: int = 0, volume: float = 1, pitch: float = 1, startPaused: bool = False) -> int: ... 
	def stopTrack(self, audio: AudioTrack) -> int: ... 
	def update(self, scene: Scene) -> None: ... 
	def getSampleRate(self) -> int: ... 
	def drawUIMonitor(self) -> None: ... 
	def drawUIQueue(self) -> None: ... 
	def pauseAll(self) -> None: ... 
	def resumeAll(self) -> None: ... 
	def stopAll(self) -> None: ... 
	def isValid(self, handlerID: int) -> bool: ... 
	def isPlaying(self, handlerID: int) -> bool: ... 
	def isPaused(self, handlerID: int) -> bool: ... 
	def setPaused(self, handlerID: int, paused: bool) -> None: ... 
	def getPaused(self, handlerID: int) -> bool: ... 
	def pause(self, handlerID: int) -> None: ... 
	def unpause(self, handlerID: int) -> None: ... 
	def stop(self, handlerID: int) -> None: ... 
	def setLoops(self, handlerID: int, loops: int) -> None: ... 
	def getLoops(self, handlerID: int) -> int: ... 
	def setVolume(self, handlerID: int, volume: float) -> None: ... 
	def getVolume(self, handlerID: int) -> float: ... 
	def setPitch(self, handlerID: int, pitch: float) -> None: ... 
	def getPitch(self, handlerID: int) -> float: ... 
	def setProgress(self, handlerID: int, progress: float) -> None: ... 
	def getProgress(self, handlerID: int) -> float: ... 
	def setSource3D(self, handlerID: int, x: float, y: float, z: float, distance: float) -> None: ... 
	def setSource3D(self, handlerID: int, entityID: int, distance: float) -> None: ... 
	def setPan(self, handlerID: int, pan: float) -> None: ... 
	def getAudio(self, handlerID: int, markAsDirty: bool = True) -> AudioTrack: ... 


class AudioTrack(Asset):
	def __init__(self): ... 
	def __init__(self, filename: str): ... 
	def uIDoubleClicked(self) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def exportOgg(self, filename: str) -> None: ... 
	def replaceOgg(self, filename: str) -> None: ... 
	def play(self, volume: float = 1, loop: int = 0, pitch: float = 1, startPaused: bool = False) -> AudioTrackInstance: ... 
	def stopAll(self) -> None: ... 
	def getDuration(self) -> float: ... 
	def getNumSamples(self) -> int: ... 
	def getNumChannels(self) -> int: ... 
	def getSampleRate(self) -> int: ... 
	def getSizeOnDisk(self) -> int: ... 
	def getSizeDecoded(self) -> int: ... 
	def getSamples(self) -> List[int]: ... 


class AudioTrackInstance():
	progress: float 
	volume: float 
	pitch: float 
	def __init__(self, handler: int = 0): ... 
	def __init__(self, other: AudioTrackInstance): ... 
	def play(self, loop: int) -> None: ... 
	def pause(self) -> None: ... 
	def resume(self) -> None: ... 
	def stop(self, fadeOut: float = 0) -> None: ... 
	def getProgress(self) -> float: ... 
	def setProgress(self, value: float) -> None: ... 
	def getDuration(self) -> float: ... 
	def setLoop(self, loop: int) -> None: ... 
	def setSource3D(self, source: Entity, maxDistance: float = 100) -> None: ... 
	def calculate3D(self, audioPos: Vector3, maxDistance: float = 100) -> bool: ... 
	def isActive(self) -> bool: ... 
	def isPlaying(self) -> bool: ... 
	def isPaused(self) -> bool: ... 
	def isValid(self) -> bool: ... 
	def setVolume(self, value: float) -> None: ... 
	def getVolume(self) -> float: ... 
	def getPitch(self) -> float: ... 
	def setPitch(self, pitch: float) -> None: ... 
	def setPan(self, pan: float) -> None: ... 
	def getTrack(self, markAsDirty: bool = True) -> AudioTrack: ... 


class Events():
	def update(self) -> None: ... 
	def forceQuit(self) -> None: ... 
	def refuseQuitStatus(self) -> None: ... 
	def getQuitStatus(self) -> bool: ... 
	def hasResized(self) -> bool: ... 
	def getJoystickCount(self) -> int: ... 
	def getJoystickName(self, id: int) -> str: ... 
	def getJoystick(self, id: int) -> Events.Joystick: ... 
	def getMouseScroll(self) -> float: ... 
	def pressed(self, t: event.Type) -> bool: ... 
	def active(self, t: event.Type) -> bool: ... 
	def released(self, t: event.Type) -> bool: ... 
	def pressed(self, t: str) -> bool: ... 
	def active(self, t: str) -> bool: ... 
	def released(self, t: str) -> bool: ... 
	def getMouseMotion(self) -> Vector2: ... 
	def setRelativeMouse(self, value: bool) -> None: ... 
	def popDroppedFiles(self) -> List[str]: ... 
	def getKeyStatus(self, t: event.Type) -> event.Status: ... 


class EventsJoystick():
	def isValid(self) -> bool: ... 
	def getName(self) -> str: ... 
	def getType(self) -> str: ... 
	def getIndex(self) -> int: ... 
	def getInstanceID(self) -> int: ... 
	def hasVibration(self) -> bool: ... 
	def hasLED(self) -> bool: ... 
	def hasAccelerometer(self) -> bool: ... 
	def hasGyroscope(self) -> bool: ... 
	def setAccelerometerEnabled(self, value: bool) -> None: ... 
	def setGyroscopeEnabled(self, value: bool) -> None: ... 
	def getAccelerometer(self) -> Vector3: ... 
	def getGyroscope(self) -> Vector3: ... 
	def isGameController(self) -> bool: ... 
	def hasAxis(self, axis: event.Controller) -> bool: ... 
	def hasButton(self, axis: event.Controller) -> bool: ... 
	def getAxisLeft(self, tolerance: float = 0.1) -> Vector2: ... 
	def getAxisRight(self, tolerance: float = 0.1) -> Vector2: ... 
	def getTriggerLeft(self) -> float: ... 
	def getTriggerRight(self) -> float: ... 
	def getControllerButton(self, btn: event.Controller) -> bool: ... 
	def getNumTouchpads(self) -> int: ... 
	def getNumTouchpadFingers(self, touchpad: int) -> int: ... 
	def getTouchpadFinger(self, touchpad: int, finger: int) -> Vector3: ... 
	def pressed(self, btn: event.Controller) -> bool: ... 
	def active(self, btn: event.Controller) -> bool: ... 
	def released(self, btn: event.Controller) -> bool: ... 
	def buttonPressed(self, btn: int) -> bool: ... 
	def buttonActive(self, btn: int) -> bool: ... 
	def buttonReleased(self, btn: int) -> bool: ... 
	def setLED(self, r: float, g: float, b: float) -> None: ... 
	def vibrate(self, left: float = 1, right: float = 1, duration: float = 0.5) -> None: ... 
	def getPowerLevel(self) -> str: ... 
	def getNumAxes(self) -> int: ... 
	def getNumBalls(self) -> int: ... 
	def getNumButtons(self) -> int: ... 
	def getNumHats(self) -> int: ... 
	def getAxis(self, axis: int, tolerance: float = 0.1) -> float: ... 
	def getAxisInitialState(self, axis: int) -> float: ... 
	def getBall(self, ball: int) -> IntVector2: ... 
	def getButton(self, button: int) -> bool: ... 
	def getHat(self, hat: int) -> IntVector2: ... 


class DebugTab():
	active: bool 
	def __init__(self): ... 
	def draw(self, fontScale: float = 1.0) -> bool: ... 
	def getName(self) -> str: ... 


class DebugTool():
	icon: str 
	name: str 
	message: str 
	def run(self, hovered: bool) -> None: ... 
	def drawOverlayUI(self, pos: Vector2, size: Vector2) -> None: ... 


class DebugUI():
	reloadFonts: bool 
	active: bool 
	showTopMenu: bool 
	clipboard: DebugUIDebugClipboard 
	activeAsset: Asset 
	activeTimeline: Timeline 
	activeSourceCode: SourceCode 
	activeAssetHistoric: List[Asset] 
	fontScale: float 
	def __init__(self, window: Window): ... 
	def update(self, events: Events) -> None: ... 
	def draw(self, window: Window) -> None: ... 
	def canQuit(self) -> bool: ... 
	def saveProject(self, dirtyOnly: bool = False) -> None: ... 
	def loadEditor(self) -> None: ... 
	def importRawAsset(self, filePath: str) -> None: ... 
	def loadEditorTools(self) -> None: ... 
	def addDefaults(self) -> None: ... 
	def addTab(self, tab: DebugTab) -> None: ... 
	def addOrReplaceTab(self, tab: DebugTab) -> None: ... 
	def setFocus(self, tab: DebugTab) -> None: ... 
	def resetFontScale(self) -> None: ... 
	def setFontScale(self, value: float) -> None: ... 
	def getFontScale(self) -> float: ... 
	def getFontScaleGain(self) -> float: ... 
	def resetFontSettings(self) -> None: ... 
	def runDPICheck(self) -> None: ... 
	def notify(self, message: str) -> None: ... 


class DebugUIDebugClipboard():
	entity: Entity 
	component: Component 


class Localization():

	# Enum: LocalizationLanguages:# "Localization" class Enumeration.
	ENGLISH : int 
	PORTUGUESE : int 
	SPANISH : int 
	LANGUAGE_COUNT : int 

	current: int 
	def __init__(self): ... 
	def saveAsJson(self, filePath: str) -> None: ... 
	def loadAsJson(self, filePath: str) -> None: ... 
	def get(self, text: str) -> str: ... 
	def getCurrent(self) -> int: ... 
	def setCurrent(self, value: int) -> None: ... 


class SceneTemplateEditor(Scene):
	reloadOnDestructor: bool 
	def __init__(self, base: EntityTemplate): ... 
	def end(self) -> None: ... 
	def endUpdate(self) -> None: ... 
	def getBase(self) -> EntityTemplate: ... 


class ConsoleTab(DebugTab):
	clearOnPlay: bool 
	def __init__(self): ... 
	def getName(self) -> str: ... 
	def showMessage(self, message: ConsoleMessage) -> None: ... 
	def drawUIFooter(self) -> None: ... 
	def clear(self) -> None: ... 


class ProfilerTab(DebugTab):
	def __init__(self): ... 
	def getName(self) -> str: ... 


class StatsForNerdsTab(DebugTab):
	counters: StatsForNerdsTabCounters 
	time: StatsForNerdsTabTimers 
	def __init__(self): ... 
	def onGameStart(self) -> None: ... 
	def onGameStop(self) -> None: ... 
	def onFirstLoad(self) -> None: ... 
	def getName(self) -> str: ... 
	def updateTimers(self) -> None: ... 


class StatsForNerdsTabCounters():
	loadedTheProject: int 
	savedTheProject: int 
	startedTheGame: int 


class StatsForNerdsTabTimers():
	inEditor: float 
	inGame: float 


class ViewportToolAsset(Asset):
	def __init__(self, owner: ViewportTab): ... 


class ViewportTab(DebugTab):
	"""
	This is where you'll be seeing most of the 3D world of your project.
Including Scenes, Entity Templates and so on.
	"""

	config: ViewportTabViewportConfig 
	displayMessage: str 
	def __init__(self): ... 
	def addTool(self, tool: DebugTool, makeCurrent: bool = False) -> None: ... 
	def getCurrentTool(self) -> DebugTool: ... 
	def getName(self) -> str: ... 
	def getMouseSurfacePos(self) -> Vector2: ... 
	def isUIElementsHovered(self) -> UIElementComponent: ... 
	def getViewportSize(self) -> Vector2: ... 
	def startGame(self) -> None: ... 
	def stopGame(self) -> None: ... 
	def scheduleStopGame(self) -> None: ... 


class ViewportTabViewportConfig():
	drawDebugIcons: bool 
	debugShadowMap: bool 
	debugRenderOut: bool 


class CameraTool():
	config: CameraTool 
	def __init__(self): ... 
	def isEnabled(self) -> bool: ... 
	def run(self) -> bool: ... 
	def mouseLook(self) -> None: ... 
	def updateMovements(self) -> None: ... 


class GeometryPaintTool(DebugTool):

	# Enum: GeometryPaintToolAlignRule:# "GeometryPaintTool" class Enumeration.
	NO_ALIGN : int 
	ALIGN_TO_BRUSH : int 
	ALIGN_TO_SURFACE : int 

	brushSize: float 
	brushStrength: int 
	parentEntity: int 
	mask: BitMask 
	layers: List[Layer] 
	def __init__(self): ... 
	def run(self, hovered: bool) -> None: ... 
	def drawOverlayUI(self, pos: Vector2, size: Vector2) -> None: ... 


class GeometryPaintToolLayer():
	base: AssetHandler[EntityTemplate] 
	minDistance: float 
	selected: bool 
	skipItself: bool 
	rangeScale: Vector2 
	rangeRoll: Vector2 
	rangePitch: Vector2 
	rangeYaw: Vector2 
	alignRule: AlignRule 


class ManipulationTool(DebugTool):
	gizmoTransform: Matrix4 
	gizmoMode: int 
	orientationMode: int 
	useSnapping: bool 
	snapPos: float 
	snapRot: float 
	snapScl: float 
	selectedEntities: Tuple[int] 
	def __init__(self): ... 
	def run(self, hovered: bool) -> None: ... 
	def drawOverlayUI(self, pos: Vector2, size: Vector2) -> None: ... 
	def getSelectedEntities(self) -> List[Entity]: ... 
	def unselectEntities(self) -> None: ... 
	def undoAction(self) -> None: ... 


class TerrainTool(DebugTool):

	# Enum: TerrainToolTerrainMode:# "TerrainTool" class Enumeration.
	MODE_SCULPT : int 
	MODE_ERASE : int 
	MODE_SMOOTH : int 
	MODE_FLATTEN : int 
	MODE_SET : int 
	MODE_EROSION : int 
	MODE_NOISE : int 
	MODE_TEXTURE_PAINT : int 


	# Enum: TerrainToolTexturePaintMode:# "TerrainTool" class Enumeration.
	COLOR_SET : int 
	COLOR_ADD : int 
	COLOR_SUBTRACT : int 
	COLOR_CHANNEL : int 

	mode: TerrainMode 
	brushSize: float 
	brushFalloff: float 
	brushStrength: float 
	noiseScale: float 
	setHeight: float 
	paintMode: TexturePaintMode 
	paintTexture: AssetHandler[Texture] 
	paintColor: Vector4 
	paintChannelSet: int 
	paintChannel: int 
	def __init__(self): ... 
	def run(self, hovered: bool) -> None: ... 
	def drawOverlayUI(self, pos: Vector2, size: Vector2) -> None: ... 


class Blur():
	size: float 
	def __init__(self, width: int, height: int, imageResReduction: float = 1.0): ... 
	def resize(self, width: int, height: int) -> None: ... 
	def blurImage(self, texture: Texture, blurAmount: int = 6) -> None: ... 
	def useBlurredImage(self, position: int) -> None: ... 
	def getBlurredImage(self) -> Texture: ... 
	def getSize(self) -> float: ... 
	def setSize(self, size: float = 1) -> None: ... 



def showMouse(show: bool) -> None: ... 
def clearBuffers(r: float, g: float, b: float, a: float = 1) -> None: ... 
def clearDepth() -> None: ... 
def setViewport(width: int, height: int) -> None: ... 
def setViewport(x: int, y: int, w: int, h: int) -> None: ... 
def init() -> None: ... 
def enableSyncGPU() -> None: ... 
def disableSyncGPU() -> None: ... 
def isSyncGPUEnabled() -> bool: ... 
def syncGPU(force: bool = False) -> None: ... 
def setTarget(window: Window) -> None: ... 
def setTarget(texture: Texture, depthTexture: Texture = None) -> None: ... 
def setTarget(textures: List[Texture], depthTexture: Texture = None) -> None: ... 
def addShader(path: str, source: str) -> None: ... 
def getShader(path: str) -> str: ... 
def removeShader(path: str) -> None: ... 
def addGeneratedShaders() -> None: ... 
def drawWireframe(value: bool) -> None: ... 
def depthTest(value: bool) -> None: ... 
def faceCulling(value: bool, backFace: bool = True) -> None: ... 
def enableErrorChecking() -> None: ... 
def disableErrorChecking() -> None: ... 
def isErrorCheckingEnabled() -> bool: ... 
def checkError(errorTitle: str, errorBody: str, showErrorDialog: bool = True, displayErrorInLog: bool = True, supressInvalidOperation: bool = True) -> bool: ... 
def enableOpenGL4Features() -> None: ... 
def pushDebugGroup(msg: str) -> None: ... 
def popDebugGroup() -> None: ... 
def nameObject(identifier: int, name: int, label: str) -> None: ... 
def displayGraphicsCardInfoUI() -> None: ... 
def displayMonitorsInfoUI() -> None: ... 

class ShaderIncludeResolver():
	"""
	This class as the name suggests is a Shader Include Resolver that expands all #includes in the shader with the appropriate codes and also maps the #line directives.
	"""

	name: str # Name of the Shader, for reference purposes.
	raw: str # Raw Shader to be parsed and resolved.
	includeMap: Dict[int,str] 
	includedFiles: Tuple[str] # Set of all files included.
	def __init__(self, shaderName: str, rawShader: str): ... 
	def resolve(self) -> str: ... # Resolves the Shader and returns the output (result).
	def getResult(self) -> str: ... 



# A Mesh is a digital representation of a 3D object and/or shape that's made up of vertices, edges and faces that defines the object's shape and structure.
# 
# You can use Cave Engine's mesh Systems for a variety of things, such as creating renderable shapes (that can be added to the scene to be seen), physics and much more.
class Vertex():
	"""
	Represents a single vertex in the mesh. It is the minimum amount of data that each Vertex composing a Mesh in Cave needs to have.
	"""

	position: Vector3 # Position of the vertex in 3D space, local do the Mesh.
	normal: Vector3 # A vector perpendicular to the surface of a vertex or face. Normals are essential for lighting calculations as they define how light interacts with the surface.
	tangent: Vector3 # A vector that lies along the surface of the vertex, pointing in the direction of the texture mapping. Tangents are primarily used for normal mapping to simulate fine surface details.
	uv: Vector2 # A 2D coordinate that maps a texture to the surface of a 3D mesh. The U and V axes represent the horizontal and vertical directions on the texture image. UV coordinates allow textures to 'wrap' around a mesh.
	def __init__(self): ... # Initializes a default Vertex with all set to zero.
	def __init__(self, other: Vertex): ... 
	def __init__(self, pos: Vector3, nor: Vector3, tan: Vector3, _uv: Vector2): ... # Initializes the vertex with position, normal, tangent, and UV data.


class VertexJoints():
	"""
	Holds Joint and Weight information for Skinned mesh vertices. This is optional for Cave meshes and only exists if the Mesh is meant to be used with an Armature + Animation.

Cave can handle up to 4 weights per vertex, meaning that the maximum amount of Bones that can deform them is 4. Those bones and weights are recpectively defined by the jointIDs and weights, where an ID equals to -1 means no Bone (so it will be skipped). Sum of all valid (ID != -1) Weights must be equal to 1.0.
	"""

	weights: Vector4 # A set of values that determine the influence of each joint (bone) on a vertex. These are used in skeletal animations to smoothly deform a mesh as the joints move.
	jointIDs: Vector4 # Identifiers (IDs) that represent the specific joints (bones) influencing the vertex. Each ID corresponds to a joint in the armature that affects the vertex during animation.
	def __init__(self): ... # Initializes the class with all IDs set to -1 and weights set to 0.0.


class VertexInfo():
	"""
	A wrapper containing all possible Vertex information.
	"""

	data: Vertex # Reference to the vertex data (Vertex class).
	joints: VertexJoints # Joint and weight data for the vertex  (VertexJoints class).


class Mesh(Asset):
	"""
	Main class representing a 3D mesh. This class is connected to the GPU and can also be used for Physics and/or custom logics as you wish.

Cave Meshes are indexed, wich means that you will find a list of vertices and also a list of indices that describes each Triangle. **NGONS are not supported in cave**, so make sure that all your polygons are Triangles.

The indices are IDs that maps the access to each Vertex store in the vertices list and every 3 indices represents one triangle.

This rendering method is optimal for games because instead of duplicating vertex data for every triangle, an indexed mesh uses a list of unique vertices and an index buffer that specifies the order in which vertices are used to form triangles. This approach reduces memory usage and improves rendering performance by reusing vertices.
	"""


	# Enum: MeshShadowPassRule:# "Mesh" class Enumeration to specify the Rendering behaviour during the Shadow Pass.
	USE_CURRENT_LOD_LEVEL : int # If set to this, the Shadow Pass will render the exact same mesh as the one being rendered in the main pass.
	ALWAYS_USE_LAST_LOD_LEVEL : int # If set to this, the Shadow Pass will ALWAYS render the last LOD level available, regardless of which one is currentlyt being used in the main pass. This could be a good performance optimization.
	SKIP_SHADOW_PASS : int # If set to this, it will NOT render anything during the shadow pass, which also means that this Mesh won't cast any Shadows. Also good for performanceoptimizations.

	vertices: List[Vertex] # List of all Vertices in the mesh.
	joints: List[VertexJoints] # List of all Joint Data for vertices. This list needs to either be empty of to have the same amount of elements as the 'vertices' list.
	indices: List[int] # Index buffer defining faces of the mesh. On every 3 indices, you have one triangle represented. Notice that this list's size (length) must be a multiple of 3 and every element in it must map to a valid ID for the vertices list.
	lod0range: float # The max distance (range) of which this Mesh can be from the Camera while still rendering the highest resolution Level of Detail. Notice that if there are no other levels, it will always render the highest one anyways and this won't be used.'
	lod: List[LodData] # A list containing all the LOD Levels in ascending order, meaning that the first item will be LOD 1, the second LOD 2 and so on.
	distanceCulling: MeshMeshDistanceCulling # A structure defining the Distance Culling Settings for this Mesh.
	scaleDistances: bool # If enabled, the World Scale of the Mesh will be used to scale the distance culling and also the LOD distances.
	shadowPassRule: ShadowPassRule # An enumeration to specify which ShadowPassRule will be used.
	hints: MeshMeshHints # A Struct defining all the Mesh hints used by this Mesh.
	def __init__(self): ... 
	def __init__(self, other: Mesh): ... 
	def getPhysicsMesh(self, createIfNone: bool = True) -> PhysicsMesh: ... 
	def rebuildPhysicsMesh(self) -> None: ... 
	def bindMeshBuffersData(self) -> None: ... 
	def reset(self, resetData: bool = True) -> None: ... # Resets the mesh, clearing all its vertex and indices data and freeing from GPU memory.
	def reload(self) -> None: ... # Resets the mesh sent to the GPU and send it again.
	def recalculateTangents(self, useUVs: bool = False) -> None: ... 
	def recalculateNormals(self) -> None: ... 
	def flipNormals(self) -> None: ... 
	def applyShadeFlat(self) -> None: ... 
	def flipIndices(self) -> None: ... 
	def recalculateIndices(self) -> None: ... 
	def mergeByDistance(self, distance: float = 0.001, ignoreUVs: bool = False, ignoreNormals: bool = False, reload: bool = True) -> None: ... # It will merge all vertices that are withing certain minimal distance (distance parameter).
	def mergeByDistanceFast(self, decimals: int = 4, reload: bool = True) -> None: ... # This is a fast (and approximate) approach to Merging nearby vertices. It always ignores the UVs and uses the position to generate a round approximation to be able to fastly compare with others. May be imprecise, but it's much faster than the regular mergeByDistance.'
	def mergeJointsByDistance(self, distance: float = 0.001, reload: bool = True) -> None: ... 
	def removeLooseVertices(self, reload: bool = True) -> None: ... # It will search and remove all Vertices that does not belong to any faces.
	def optimizeMesh(self, reload: bool = True) -> None: ... # This Method will perform a series of Mesh optimizations to make sure that it is optimal for rendering. This includes Merging the Vertices and Joints by distance, Optimizing Vertex Cache and Overdraw and also optimizing Vertex Fetch. Note: This may be SLOW and probably not suitable (or meant to) for real time use cases.
	def use(self) -> int: ... 
	def useLod(self, lodLevel: int = 0) -> int: ... 
	def getLodLevelForDistance(self, distance: float) -> int: ... 
	def draw(self) -> None: ... 
	def drawInstanced(self, instanceCount: int) -> None: ... 
	def drawLines(self, width: float = 1) -> None: ... 
	def drawPoints(self, thickness: float = 5) -> None: ... 
	def getCopy(self) -> Mesh: ... 
	def getRandomPoint(self) -> Vertex: ... 
	def getClosestVertexID(self, pos: Vector3) -> int: ... # Given a position (in local Mesh space), returns an ID for the closest Vertex to that position. This ID can be used to access the vertex in the vertices list.
	def getClosestVertex(self, pos: Vector3) -> Vertex: ... # Given a position (in local Mesh space), returns a copy of the closest Vertex to that position.
	def getClosestTriangleID(self, pos: Vector3) -> Tuple[int,Vector3]: ... # Given a position (in local Mesh space), returns an ID for the closest Triangle to that position. In order to properly sample the 3 vertices that builds this triangle, you need to multiply this ID by 3 and then use it to access the 3 following vertex IDs in the indices list. Also returns the closest position in tha triangle.
	def getClosestTriangle(self, pos: Vector3) -> Tuple[IntVector3,Vector3]: ... # Given a position (in local Mesh space), returns an IntVector3 containing the three vertex IDs that builds the closest Triangle to that position. You can use those three IDs to access each Vertex in the vertex list. Also returns the closest position in tha triangle.
	def getClosestTrianglesIDs(self, pos: Vector3, count: int) -> List[Tuple[int,Vector3]]: ... 
	def getClosestTriangles(self, pos: Vector3, count: int) -> List[Tuple[IntVector3,Vector3]]: ... 
	def getClosestPoint(self, pos: Vector3) -> Vertex: ... # Given a position (in local Mesh space), returns the closest point in the entire mesh surface to that position. The point could be in a vertex, edge or withing the triangle surface.
	def getTriangleNeighborsID(self, triangle: int) -> List[int]: ... # Given a Triangle, returns all other triangles that shares at least one vertice with it.
	def getEdgeTrianglesIDs(self, e0: int, e1: int) -> List[int]: ... # Given an Edge, returns all other triangles that shares this same edge
	def walkInMesh(self, initialPos: Vector3, initialDir: Vector3, length: float) -> List[Vector3]: ... # Given an initialPos, initialDir and length, it walks in the mesh surface, starting from the closest point in mesh to the initialPos and initially going to the initialDir direction, until it moved the desired length. Returns the map of waypoints to this walk. First one is always the closest point to the initialPos.
	def getBoundingBox(self, keepAspect: bool = True, transf: Transform = None) -> Transform: ... 
	def getAABB(self, transf: Transform = None) -> Tuple[Vector3,Vector3]: ... 
	def getCachedBoundingBox(self) -> Matrix4: ... 
	def recalculateCachedBoundingBox(self) -> None: ... 
	def removeAnimationJointsIfUnused(self, reload: bool = True) -> None: ... 
	def hasAnimationData(self) -> bool: ... 
	def appendVertex(self, pos: Vector3, normal: Vector3, tangent: Vector3, uv: Vector2) -> None: ... 
	def addLine(self, origin: Vector3, target: Vector3, color: Vector3) -> None: ... 
	def mergeVertices(self, targetIdx: int, otherIdx: int) -> bool: ... 
	def getEdges(self, vertexIdx: int) -> Tuple[int]: ... 
	def getFaces(self, vertexIdx: int) -> Tuple[int]: ... 
	def getAllEdges(self) -> Tuple[Tuple[int,int]]: ... 
	def getAverageNormalLength(self, vertexIdx: int) -> float: ... 
	def decimate(self, ratio: float = 0.5, reload: bool = True) -> None: ... 
	def generateLodLevels(self, lodLevels: int = 1, distanceFactor: float = 3, reload: bool = True) -> None: ... 
	def addFace(self, vList: List[Vertex]) -> None: ... 
	def addMesh(self, other: Mesh) -> None: ... 
	def addMeshTransformed(self, other: Mesh, transform: Transform) -> None: ... 
	def addVolume(self, transform: Transform) -> None: ... 
	def addNgon(self, ngon: List[Vector3]) -> None: ... 
	def addNgon(self, ngon: List[Vertex]) -> None: ... 
	def addPlane(self, transform: Transform = None) -> None: ... # Adds a Plane Shape into the Mesh, transforming it by the given Transform (optional).
	def addCube(self, transform: Transform = None) -> None: ... # Adds a Cube Shape into the Mesh, transforming it by the given Transform (optional).
	def addCylinder(self, subdivisions: int = 12, transform: Transform = None) -> None: ... # Adds a Plane Cylinder into the Mesh, transforming it by the given Transform (optional).
	def addCone(self, subdivisions: int = 12, transform: Transform = None) -> None: ... # Adds a Cone Shape into the Mesh, transforming it by the given Transform (optional).
	def addUvSphere(self, numRings: int = 32, numSegments: int = 16, transform: Transform = None) -> None: ... # Adds an UV Sphere Shape into the Mesh, transforming it by the given Transform (optional).
	def addGrid(self, gridSize: int = 12, transform: Transform = None) -> None: ... # Adds a Grid Shape into the Mesh, transforming it by the given Transform (optional). A Grid is basically a Plane with subdivisions.
	def applyTransform(self, transform: Transform, bindData: bool = True) -> None: ... 
	def applyMovement(self, move: Vector3, bindData: bool = True) -> None: ... 
	def getCurrentIndicesCount(self) -> int: ... 
	def getObj(self, indicesOffset: int = 0) -> str: ... 
	def buildMeshWithLod(self, lodLevel: int, bindData: bool = True) -> Mesh: ... 
	def disableShadowRendering(self) -> None: ... 
	def enableShadowRendering(self, useLastLod: bool = False) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 


class MeshLodData():
	indices: List[int] 
	range: float 
	ratio: float 


class MeshMeshDistanceCulling():
	enable: bool 
	enableDither: bool 
	distance: float 


class MeshMeshHints():
	transform: Transform 
	material: AssetHandler[Material] 
	armature: AssetHandler[Armature] 
	animation: AssetHandler[Animation] 


class PostProcessing(Asset):
	passes: List[Filter] 
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def uIThumbnailDrawn(self, pos: Vector2, size: Vector2) -> None: ... 


class PostProcessingFilter():
	name: str 
	active: bool 
	uniforms: ShaderUniforms 
	bindPyCodeStaging: SourceCode 
	bindPyCode: str 
	shader: ShaderProgram 
	def __init__(self, name: str, shaderSource: str = ""): ... 
	def isValid(self) -> bool: ... 
	def submit(self) -> None: ... 
	def parseUniforms(self) -> None: ... 


class Renderer(Asset):
	postProcessing: AssetHandler[PostProcessing] 
	shaderProgramOverride: AssetHandler[ShaderProgram] 
	depthPrepass: bool 
	debug: RendererRendererDebug 
	def __init__(self): ... 
	def render(self, view: Camera, rGraph: RenderGraph, renderToTexture: bool = False) -> None: ... 
	def renderToTexture(self, view: Camera, rGraph: RenderGraph, resolution: IntVector2 = IntVector2(0,0)) -> Texture: ... 
	def setResolution(self, width: int, height: int, force: bool = False) -> None: ... 
	def setResolution(self, res: IntVector2, force: bool = False) -> None: ... 
	def getResolution(self) -> IntVector2: ... 
	def setVirtualAspect(self, aspect: float) -> None: ... 
	def getAspect(self) -> float: ... 
	def reloadShadowMaps(self, shadowRes: IntVector2 = IntVector2(2048)) -> None: ... 
	def getFinalRender(self) -> Texture: ... 
	def getFinalRenderBlurred(self) -> Texture: ... 
	def getPositionAt(self, x: float, y: float) -> Vector4: ... 
	def getNormalAt(self, x: float, y: float) -> Vector4: ... 
	def getAssetAt(self, x: float, y: float) -> Asset: ... 
	def getMainShader(self, markAsDirty: bool = True) -> ShaderProgram: ... 
	def getDefaultTextures(self) -> List[Texture]: ... 
	def getShadowTextures(self) -> List[Texture]: ... 


class RendererRendererDebug():
	wireframe: bool 
	wireframeLineWidth: float 



# Enum: ShaderProgramMacros: 
SHADER_SHADOW_PASS : int 
SHADER_ALPHA_BLEND : int 
SHADER_MATERIAL_SHADELESS : int 
SHADER_MATERIAL_HAS_NORMAL_MAP : int 
SHADER_SCENE_SHADED : int 
SHADER_SCENE_HAS_AMBIENT : int 
SHADER_SCENE_HAS_MIST : int 
SHADER_SCENE_HAS_SHADOWS : int 
SHADER_TERRAIN : int 


# Enum: ShaderLocations: # The ShaderLocations enum specifies where to bind each Texture in the main render pass. It's used internally by the engine.
SHADER_LOCATION_HEIGHTMAP : int 
SHADER_LOCATION_AMBIENT_TEX : int 
SHADER_LOCATION_MIST_TEX : int 
SHADER_LOCATION_SKY_TEX : int 
SHADER_LOCATION_MATERIALS : int 
SHADER_LOCATION_SHADOWMAPS : int 

class ShaderProgram(Asset):
	uniforms: ShaderUniforms 
	vertex: SourceCode 
	geometry: SourceCode 
	fragment: SourceCode 
	def __init__(self): ... 
	def __init__(self, vert: str, frag: str, name: str = "Shader"): ... 
	def __init__(self, vert: str, geom: str, frag: str, name: str): ... 
	def __init__(self, other: ShaderProgram): ... 
	def isValid(self) -> bool: ... 
	def reload(self) -> None: ... 
	def use(self, permutation: int = 0) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def uIThumbnailDrawn(self, pos: Vector2, size: Vector2) -> None: ... 
	def set(self, name: str, value: int) -> None: ... 
	def set(self, name: str, value: int) -> None: ... 
	def set(self, name: str, value: bool) -> None: ... 
	def set(self, name: str, value: float) -> None: ... 
	def set(self, name: str, value: Vector2) -> None: ... 
	def set(self, name: str, value: IntVector2) -> None: ... 
	def set(self, name: str, value: Vector3) -> None: ... 
	def set(self, name: str, value: IntVector3) -> None: ... 
	def set(self, name: str, value: Vector4) -> None: ... 
	def set(self, name: str, value: IntVector4) -> None: ... 
	def set(self, name: str, value: Matrix3) -> None: ... 
	def set(self, name: str, value: Matrix4) -> None: ... 
	def setUniformBuffer(self, name: str, bindingPoint: int) -> None: ... 
	def getUniformComment(self, uniformName: str) -> str: ... 
	def getUniformLocation(self, name: str) -> int: ... 


class ShaderUniforms():
	"""
	This class is a container that stores and represents Shader Uniforms in a way that you can see, access and modify.
	"""

	order: List[str] 
	def __init__(self): ... 
	def __init__(self, other: ShaderUniforms): ... 
	def reset(self) -> None: ... # Clears all the Uniform lists, deleting them all.
	def parse(self, shaderSource: str) -> None: ... # Given a shader source code, parses it and includes all its uniform values to this class.
	def sync(self, base: ShaderUniforms) -> None: ... # Syncs this uniforms with the base Shader Uniform, meaning that any uniform in this class that does not exist in the base Shader Uniforms will be deleted and any new/different uniform in it will be added to this one.
	def bind(self, shader: ShaderProgram, nextTexLocation: int) -> None: ... 
	def get(self, name: str) -> Any: ... # Given an Uniform name, returns its value or None if it doesn't exist.
	def set(self, name: str, value: Any) -> None: ... # Given an Uniform name, sets it to the provided value. Creates a new uniform if there was no one with this name.
	def getAll(self) -> dict: ... # Returns a dictionary containing A COPY of all Uniforms and Values.


class TextureParameters():
	wrapX: int 
	wrapY: int 
	minFilter: int 
	magFilter: int 
	borderColor: Vector4 


class Texture(Asset):
	texParams: TextureParameters 
	resident: bool 
	def __init__(self): ... 
	def __init__(self, width: int, height: int, format: int = 0x8058, pixelFormat: int = 0x1405): ... 
	def __init__(self, other: Texture): ... 
	def saveAsPNG(self, filePath: str, flipVertical: bool = True) -> None: ... 
	def readPixels(self) -> List[int]: ... 
	def readPixelFloat(self, x: float, y: float) -> Vector4: ... 
	def readPixelFloatAbsolute(self, x: int, y: int) -> Vector4: ... 
	def setPixels(self, pixels: List[int]) -> None: ... 
	def drawUIThumbnail(self, displayInfo: bool = True, hoverText: str = "Preview") -> bool: ... 
	def isMutable(self) -> bool: ... 
	def isResident(self) -> bool: ... 
	def getResident(self) -> bool: ... 
	def setResident(self, value: bool) -> None: ... 
	def makeResident(self) -> None: ... 
	def getTextureID(self) -> int: ... 
	def getHeight(self) -> int: ... 
	def getWidth(self) -> int: ... 
	def getResolution(self) -> IntVector2: ... 
	def setResolution(self, width: int, height: int) -> None: ... 
	def updateTextureParameters(self, useTexture: bool = True) -> None: ... 
	def getAspect(self) -> float: ... 
	def isGammaSpace(self) -> bool: ... 


class UniformBuffer():
	def __init__(self, size: int, bindingPoint: int, usageHint: int = 0x88E8): ... 
	def use(self) -> None: ... 
	def setBufferData(self, offset: int, ptrData: None, dataSize: int) -> None: ... 
	def useAndSetBufferData(self, offset: int, ptrData: None, dataSize: int) -> None: ... 
	def getBufferID(self) -> int: ... 
	def getBindingPoint(self) -> int: ... 


class SceneUBO():
	applyAmbient: int 
	ambientFactor: float 
	applyShading: int 
	mistUse: int 
	mistStart: float 
	mistDistance: float 
	mistFalloff: float 
	mistIntensity: float 
	cameraPosition: Vector3 
	cameraAperture: float 
	cameraNear: float 
	cameraFar: float 
	cameraInvVP: Matrix4 
	useShadows: int 
	shadowPCFsamples: int 
	shadowPCFradius: float 
	shadowBias: float 
	shadowBiasAngleScale: float 
	shadowInfluence: float 
	sunDir: Vector3 
	sunColor: Vector3 


class PointLightInfoUBO():
	position: Vector3 
	spotAngle: float 
	color: Vector3 
	radius: float 
	direction: Vector3 
	spotFalloff: float 


class PointLightsUBO():
	pointLightCount: int 


class InstanceInfoUBO():
	transform: Matrix4 
	tint: Vector4 
	id: IntVector4 


class InstancesUBO():
	pass


class ArmatureUBO():
	boneCount: int 


class Animation(Asset):
	frameStart: float 
	frameEnd: float 
	speed: float 
	rootMotion: AnimationRootMotion 
	callbacks: AnimationCallbacks 
	def __init__(self): ... 
	def __init__(self, start: float, end: float): ... 
	def __init__(self, other: Animation): ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def uIDoubleClicked(self) -> None: ... 
	def uIThumbnailDrawn(self, pos: Vector2, size: Vector2) -> None: ... 
	def getTransformAt(self, channelName: str, frame: float) -> Transform: ... 
	def getChannel(self, channelName: str, addIfNone: bool = True) -> AnimationChannels: ... 
	def getChannels(self) -> Dict[str,AnimationChannels]: ... 


class AnimationRootMotion():
	channel: str 
	x: bool 
	y: bool 
	z: bool 


class AnimationCallbacks():
	onStart: SourceCode 
	onEnd: SourceCode 
	onFrame: List[Tuple[float,SourceCode]] 



# Enum: AnimationInterpolation: 
LINEAR : int 
CONSTANT : int 

class AnimationChannels():
	interpolation: AnimationInterpolation 
	def __init__(self): ... 
	def __init__(self, other: AnimationChannels): ... 
	def drawUISequencer(self) -> None: ... 
	def sort(self) -> None: ... 
	def addPositionKeyframe(self, frame: float, position: Vector3) -> None: ... 
	def addRotationKeyframe(self, frame: float, rotator: Quaternion) -> None: ... 
	def addScaleKeyframe(self, frame: float, scale: Vector3) -> None: ... 
	def getPosition(self, frame: float) -> Vector3: ... 
	def getRotation(self, frame: float) -> Quaternion: ... 
	def getScale(self, frame: float) -> Vector3: ... 
	def getFloorPositionAt(self, frame: float) -> Vector3: ... 
	def getFloorRotationAt(self, frame: float) -> Quaternion: ... 
	def getFloorScaleAt(self, frame: float) -> Vector3: ... 
	def hasPositionKeyframes(self) -> bool: ... 
	def hasRotationKeyframes(self) -> bool: ... 
	def hasScaleKeyframes(self) -> bool: ... 


class Armature(Asset):
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 
	def getBoundingBox(self, keepAspect: bool = True, transf: Transform = None) -> Transform: ... 
	def getAABB(self, transf: Transform) -> Tuple[Vector3,Vector3]: ... 
	def drawDebugLines(self, transform: Transform, scene: Scene, showParenting: bool = False) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def update(self, animation: Animation, frame: float, blend: float = 1, filter: AnimationFilter = None) -> None: ... 
	def applyDeformation(self, mesh: Mesh, reloadMesh: bool = True) -> None: ... # This will destructively apply the Armature deformation to the destination mesh, meaning that all bone transforms will be calculated on the CPU and applied to each Vertex. It will also clear the Vertex Joints data. You can use this if you need to retrieve back the final pose of a mesh but CPU side. Keep in mind that is could be an expensive operation.
	def hasBone(self, boneName: str) -> bool: ... 
	def addBone(self, boneName: str, bone: Bone) -> None: ... 
	def getBone(self, boneName: str, addIfNone: bool = False) -> Bone: ... 
	def getBone(self, id: int) -> Bone: ... 
	def getBones(self) -> List[Bone]: ... 
	def getBoneNames(self) -> List[str]: ... 
	def setBoneParent(self, child: str, parent: str) -> None: ... 


class Bone(NodeTransform):
	name: str 
	offset: Matrix4 
	index: int 
	def getAnimatedMatrix(self) -> Matrix4: ... 
	def setOffset(self, offset: Matrix4) -> None: ... 
	def applyOffset(self) -> None: ... 
	def getOffset(self) -> Matrix4: ... 
	def getIndex(self) -> int: ... 
	def setIndex(self, index: int) -> None: ... 
	def getChildren(self) -> List[Bone]: ... 
	def inverseKinematics(self, targetPosition: Vector3, chainLength: int, blend: float = 1, maxIterations: int = 10, tolerance: float = 0.001) -> int: ... # Computes the optimal rotations for a chain of bones (parents) for this bone to reach the targetPosition while maintaining natural movement constraints. The targetPosition MUST BE in local space (relative to the Armature Entity), so make sure you untransform it first if you're handling world coordinates. Returns the number of iterations spent to evaluate the final pose.
	def twoPartIK(self, targetPosition: Vector3, blend: float = 1, preserveRotation: bool = True) -> None: ... # Two Part IK also solves inverse Kinematics but it is specialized in chain length equal to two and it's usually better (and faster) at doing it than the regular one.


class Font(Asset):
	def __init__(self, resolution: int = 2048): ... 
	def buildAtlas(self, filePath: str) -> None: ... 
	def buildAtlas(self, data: int, size: int) -> None: ... 
	def exportTTF(self, filename: str) -> None: ... 
	def replaceTTF(self, filename: str) -> None: ... 
	def use(self, slot: int = 0) -> None: ... 
	def generateText(self, text: str, bindMesh: bool = True, scale: float = 1.0, spacing: float = 1) -> Mesh: ... 


class Material(Asset):
	"""
	Material class is used to define the visuals for any given Mesh.
It allows you to specify custom colors, textures, settings and Shaders to render the Meshes.
	"""

	mask: BitMask 
	shadeless: bool 
	alphaBlend: bool 
	backfaceCulling: bool 
	shaderOverride: AssetHandler[ShaderProgram] 
	uniforms: ShaderUniforms 
	def __init__(self, name: str = "Basic Material"): ... 
	def __init__(self, other: Material): ... 
	def uIDoubleClicked(self) -> None: ... 
	def use(self, _shader: ShaderProgram, shadowPass: bool = False) -> None: ... 
	def updateShaderPermutations(self) -> int: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def isAlphaBlend(self) -> bool: ... 
	def isOpaque(self) -> bool: ... 
	def getCopy(self) -> Material: ... 
	def updateUniforms(self) -> None: ... 


class Sampler2D():
	texture: AssetHandler[Texture] 
	color: Vector4 
	def __init__(self): ... 
	def __init__(self, _texture: Texture): ... 
	def __init__(self, textureName: str): ... 
	def __init__(self, r: float, g: float, b: float, a: float = 1): ... 
	def __init__(self, r: float, g: float, b: float, a: float, assetID: int): ... 
	def __init__(self, r: float, g: float, b: float, a: float, assetID: int, textureName: str): ... 
	def __init__(self, r: float, g: float, b: float, a: float, textureName: str): ... 
	def __init__(self, other: Sampler2D): ... 
	def asString(self) -> str: ... 
	def setTexture(self, tex: str) -> None: ... 
	def getTexture(self, stagingLocation: int, markAsDirty: bool = True) -> Texture: ... 
	def use(self, shader: ShaderProgram, uniform: str, location: int) -> None: ... 
	def drawTextureOnlyUI(self, samplerName: str, icon: str = ICON_FA_PALETTE) -> None: ... 
	def set(self, r: float, g: float, b: float, a: float = 1) -> None: ... 
	def set(self, value: float) -> None: ... 


class RenderableSun(Camera):
	color: Vector3 
	intensity: float 
	shadow: RenderableSunShadowSettings 
	hour: float 
	angle: float 
	def __init__(self): ... 
	def getProjection(self) -> Matrix4: ... 
	def getDirection(self) -> Vector3: ... 
	def getColor(self) -> Vector3: ... 
	def getHour(self) -> float: ... 
	def setHour(self, value: float) -> None: ... 
	def getAngle(self) -> float: ... 
	def setAngle(self, value: float) -> None: ... 
	def alignTransformToView(self, cam: Camera) -> None: ... 


class RenderableSunShadowSettings():
	cast: bool 
	pcfSamples: int 
	pcfRadius: float 
	bias: float 
	influence: float 


class RenderGraph():
	sun: RenderableSun 
	config: RenderGraphConfig 
	postProcessingOverride: AssetHandler[PostProcessing] 
	shaderProgramOverride: AssetHandler[ShaderProgram] 
	debug: RenderGraphDebugConfig 
	def __init__(self): ... 
	def updateRenderGraph(self, view: Camera) -> None: ... 
	def draw(self, view: Camera, defaultShader: ShaderProgram = None, opaquePass: bool = True, shadowPass: bool = False, depthPrepass: bool = False) -> None: ... 
	def getShaderPermutations(self, shadowPass: bool = False, opaquePass: bool = True) -> int: ... 
	def updateUniformBuffers(self, view: Camera) -> None: ... 
	def updateShaderUniforms(self, shader: ShaderProgram) -> None: ... 
	def getEntityFromLookup(self, pixelCoord: IntVector4) -> Entity: ... 
	def getEntityLookup(self, entity: Entity) -> IntVector4: ... 
	def getActiveEntityLookup(self) -> IntVector4: ... 
	def setActiveEntity(self, shader: ShaderProgram) -> None: ... 
	def add(self, obj: MeshComponent) -> None: ... 
	def remove(self, obj: MeshComponent) -> bool: ... 
	def addProxy(self, obj: MeshProxyComponent) -> None: ... 
	def removeProxy(self, obj: MeshProxyComponent) -> None: ... 
	def addLight(self, obj: LightComponent) -> None: ... 
	def removeLight(self, obj: LightComponent) -> bool: ... 


class RenderGraphConfig():
	applyShading: bool 
	ambient: RenderGraphConfigAmbient 
	mist: RenderGraphConfigMist 
	sky: RenderGraphConfigSky 
	atmosphere: RenderGraphConfigAtmosphere 
	background: Vector3 
	ambientCol: Vector3 
	ambientIntensity: float 


class RenderGraphConfigAmbient():
	use: bool 
	factor: float 
	color: Sampler2D 


class RenderGraphConfigMist():
	use: bool 
	start: float 
	distance: float 
	falloff: float 
	intensity: float 
	color: Sampler2D 


class RenderGraphConfigSky():
	blur: float 
	intensity: float 
	angle: float 
	color: Sampler2D 


class RenderGraphConfigAtmosphere():
	planetRadius: float 
	atmHeight: float 
	sunIntensity: float 


class RenderGraphDebugDrawPass():
	drawCalls: int 
	drawCallsInstanced: int 
	meshBindings: int 
	materialBindings: int 
	shaderBindings: int 
	drawnRenderables: int 
	culledRenderables: int 
	culledByDistance: int 
	vertices: int 
	triangles: int 


class RenderGraphDebugConfig():
	grid: bool 
	drawPassInfo: List[Tuple[str,DebugDrawPass]] 


class ImageTexture(Texture):
	def __init__(self): ... 
	def __init__(self, file: str, forceLinearSpace: bool = False): ... 
	def __init__(self, data: int, size: int, forceLinearSpace: bool = False): ... 
	def __init__(self, rgbaBitmap: int, width: int, height: int, forceLinearSpace: bool = False): ... 
	def __init__(self, other: ImageTexture): ... 
	def resize(self, newWidth: int, newHeight: int) -> bool: ... 
	def compressDXT(self) -> bool: ... 
	def getCopy(self) -> Texture: ... 


class UICanvas():
	def __init__(self): ... 
	def updateElements(self) -> None: ... 
	def draw(self) -> None: ... 
	def add(self, element: UIElementComponent) -> None: ... 
	def remove(self, element: UIElementComponent) -> None: ... 
	def getAll(self) -> List[UIElementComponent]: ... 


class UIRect():
	left: float 
	right: float 
	top: float 
	bottom: float 
	def __init__(self): ... 
	def __init__(self, l: float, r: float, t: float, b: float): ... 
	def isPointInside(self, point: Vector2) -> bool: ... 
	def snapToGrid(self, gridSize: float = 0.05) -> None: ... 
	def getWidth(self) -> float: ... 
	def getHeight(self) -> float: ... 
	def getScale(self) -> Vector2: ... 
	def getCenter(self) -> Vector2: ... 


class UIVector():
	"""
	This class is Specifically used when handling Game User Interfaces, since it can have either absolute (in pixels) or relative (in percentage, 0 to 1) x and y values.
It also holds anchoring information for each Axis. You need to check if the axis is using relative values (if not, then it is using its pixel values). Directly setting a relative OR pixel value changes this.
	"""

	relativeX: bool # Its relative position on the X axis (same as relative.x).
	relativeY: bool # Its relative position on the Y axis (same as relative.y).
	anchoring: IntVector2 # Its anchor points (x and y axis). Each axis can be -1, 0 or 1.
	pixel: IntVector2 # Its absolute position (x and y) in screen pixels.
	relative: Vector2 # Its relative position (x and y).
	anchoringX: int # Its anchor point on the X axis (same as anchoring.x). Can be -1, 0 or 1.
	anchoringY: int # Its anchor point on the Y axis (same as anchoring.y). Can be -1, 0 or 1.
	def __init__(self): ... 
	def __init__(self, other: UIVector): ... 
	def __init__(self, x: float, y: float): ... 
	def get(self, parentScale: Vector2 = Vector2(1,1)) -> Vector2: ... 
	def getX(self, parentScale: float = 1) -> float: ... 
	def getY(self, parentScale: float = 1) -> float: ... 
	def set(self, value: Vector2, parentScale: Vector2 = Vector2(1,1)) -> None: ... 
	def setPixelX(self, x: int) -> None: ... 
	def setPixelY(self, y: int) -> None: ... 
	def setPixel(self, x: int, y: int) -> None: ... # Setter for the pixel variable
	def setPixel(self, value: IntVector2) -> None: ... # Setter for the pixel variable
	def getPixel(self) -> IntVector2: ... # Getter for the pixel variable.
	def setRelativeX(self, x: float) -> None: ... 
	def setRelativeY(self, y: float) -> None: ... 
	def setRelative(self, x: float, y: float) -> None: ... # Setter for the relative variable
	def setRelative(self, value: Vector2) -> None: ... # Setter for the relative variable.
	def getRelative(self) -> Vector2: ... # Getter for the relative variable.
	def getAnchoringX(self) -> int: ... 
	def setAnchoringX(self, value: int) -> None: ... 
	def getAnchoringY(self) -> int: ... 
	def setAnchoringY(self, value: int) -> None: ... 
	def isRelativeX(self) -> bool: ... # Checks if the X axis should use its relative (returns True) or pixel value (returns False).
	def isRelativeY(self) -> bool: ... # Checks if the Y axis should use its relative (returns True) or pixel value (returns False).
	def asString(self) -> str: ... 


class UIStyle(Asset):
	nineSliceUse: bool 
	nineSliceBorder: float 
	colorBase: UIStyleColor 
	colorHovered: UIStyleColor 
	colorPressed: UIStyleColor 
	onHoverIn: SourceCode 
	onHoverOut: SourceCode 
	onClickIn: SourceCode 
	onClickOut: SourceCode 
	def __init__(self): ... 
	def __init__(self, other: UIStyle): ... 
	def uIDoubleClicked(self) -> None: ... 
	def uIThumbnailDrawn(self, pos: Vector2, size: Vector2) -> None: ... 


class UIStyleColor():
	image: AssetHandler[Texture] 
	tint: Vector3 
	alpha: float 
	blurBackground: float 
	def __init__(self): ... 


class Documentation(Asset):
	"""
	You can use this Documentation asset to write any custom docs, reminders, tutorials, lists you want to help you during development.
It uses Markdown to format it for you.
	"""

	text: SourceCode 
	def __init__(self): ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 





def pauseFrameCapture() -> None: ... 
def resumeFrameCapture() -> None: ... 
def isFrameCaptureActive() -> bool: ... 
def getStoreFrameCount() -> int: ... 
def setStoreFrameCount(value: int) -> None: ... 
def getScopeTraceBack() -> str: ... 
def saveProfilerCapture() -> None: ... 
def getScopeTime(scope: str) -> int: ... 
def getScopeTimeAverage(scope: str) -> int: ... 

class SourceCode():

	# Enum: SourceCodeSourceType:# "SourceCode" class Enumeration.
	PYTHON : int 
	GLSL : int 
	MARKDOWN : int 

	source: str 
	def watch(self) -> bool: ... 
	def getWatchPath(self) -> str: ... 
	def __str__(self) -> str: ...
	def __eq__(self, other) -> bool: ... # self == other
	def __eq__(self, other) -> bool: ... # self == other
	def __ne__(self, other) -> bool: ... # self != other
	def __ne__(self, other) -> bool: ... # self != other



# You will find bellow the classes required to implement a State Machine system, including the cave.State and cave.StateMachine classes.
# These allow you to define and manage Finite State Machines (FSM) for a wide range of practical applications.
class State():
	"""
	State class for the cave.StateMachine(...) System.
You can inherit from this Class to create your own custom states to feed your State Machines.
	"""

	entity: Entity # Reference to the Entity that owns this State. Set by the StateMachine before the State runs. Can be None.
	component: Component # Reference to the Component that owns this State. Set by the StateMachine before the State runs. Can be None.
	def __init__(self): ... # Initializes a State object with its owner (entity and component_) set to None by default. The owner is expected to be set by the StateMachine before the State runs.
	def start(self) -> None: ... # This method is called when the state is entered. Override it in derived classes to define initialization logic.
	def update(self) -> Any: ... # Called every frame while the state is active. Returns the next state (None to remain in the current state or a new state to transition).
	def end(self) -> None: ... # This method is called when the state is exited. Override it in derived classes to define cleanup logic.
	def setOwners(self, _entity: Entity, _component: Component) -> None: ... 


class StateMachine():
	"""
	Manages the execution and transitions between different States (that inherts from cave.State).
	"""

	entity: Entity # Reference to the Entity that owns this StateMachine. Can be None.
	component: Component # Reference to the Component that owns this StateMachine. Can be None.
	def __init__(self): ... # Default constructor for StateMachine. Initializes the StateMachine without an owner, meaning that entity and component are set to None.
	def __init__(self, _entity: Entity): ... # Constructor for StateMachine with an Entity owner. Associates the StateMachine with the specified Entity. Component is set to None.
	def __init__(self, _cmp: Component): ... # Constructor for StateMachine with a Component owner. Associates the StateMachine with the specified Component. Entity is set to the given Component's owner Entity.'
	def run(self) -> bool: ... # Executes the current state's Update method, manages the returned state, and performs transitions if necessary.
	def setState(self, newState: Any) -> bool: ... # Transitions the StateMachine to a new state. Calls the End method of the current state (if any) and the Start method of the new state.


class Timeline(Asset):

	# Enum: TimelineChannelBlend:# "Timeline" class Enumeration.
	BLEND_NONE : int 
	BLEND_LINEAR : int 
	BLEND_EASE : int 
	BLEND_QUADRIC : int 

	cameras: SortedFrames[Tuple[int,int]] 
	cameraNames: Dict[int,str] 
	callbacks: SortedFrames[SourceCode] 
	audioTracks: List[SortedFrames[AudioInstance]] 
	entities: List[Timeline.EntityChannel] 
	cursor: float 
	frameStart: float 
	frameEnd: float 
	def __init__(self): ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def uIDoubleClicked(self) -> None: ... 
	def applyActiveCamera(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def applyActivityToEntities(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def applyFrameToEntities(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def applyAutoKeyframe(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def getEntityChannel(self, ent: Entity, createIfNone: bool = True) -> Timeline.EntityChannel: ... 
	def getComponentChannel(self, ent: Entity, cmp: Component, createIfNone: bool = True) -> Timeline.ComponentChannel: ... 
	def getChannel(self, ent: Entity, cmp: Component, channel: str, createIfNone: bool = True) -> Timeline.Channel: ... 
	def isKeyframed(self, ent: Entity, cmp: Component, channel: str) -> bool: ... 


class TimelineChannel():
	blend: Timeline.ChannelBlend 
	def __init__(self): ... 
	def __init__(self, other: Timeline.Channel): ... 
	def setProp(self, propName: str) -> None: ... 
	def setProp(self, getterName: str, setterName: str) -> None: ... 
	def getValuePy(self, cmp: Component) -> Any: ... 
	def setValuePy(self, cmp: Component, obj: Any) -> None: ... 
	def findFloor(self, frame: float) -> int: ... 
	def findCeil(self, frame: float) -> int: ... 
	def getFrameValue(self, frame: float) -> Any: ... 
	def getFrameValue(self, id: int) -> Any: ... 
	def calculateFrame(self, frame: float, cmp: Component) -> None: ... 
	def applyAutoKeyframe(self, frame: float, cmp: Component) -> None: ... 
	def getFrames(self) -> List[Tuple[float,Any]]: ... 
	def getNumFrames(self) -> int: ... 
	def set(self, frame: float, value: Any, epsilon: float = 0.0001) -> None: ... 
	def set(self, id: int, value: Any) -> None: ... 
	def getFrame(self, id: int) -> float: ... 
	def setFrame(self, id: int, newFrame: float) -> None: ... 
	def move(self, frame: float, newFrame: float, epsilon: float = 0.0001) -> bool: ... 
	def move(self, id: int, newFrame: float) -> bool: ... 
	def find(self, frame: float, epsilon: float = 0.0001) -> int: ... 
	def remove(self, id: int) -> None: ... 
	def sortFrames(self) -> None: ... 


class TimelineComponentChannel():
	id: int 
	localID: Tuple[str,int] 
	channels: Dict[str,Timeline.Channel] 
	def getComponent(self, ent: Entity) -> Component: ... 


class TimelineEntityChannel():
	id: int 
	nameID: str 
	components: List[Timeline.ComponentChannel] 
	def getEntity(self, scene: Scene, owner: Entity = None) -> Entity: ... 
	def isActive(self, frame: float) -> bool: ... 
	def getFrameID(self, frame: float) -> int: ... 
	def findFrameID(self, frame: float, epsilon: float = 0.0001) -> int: ... 
	def setActive(self, frame: float, active: bool) -> None: ... 
	def setActive(self, id: int, active: bool) -> None: ... 
	def remove(self, id: int) -> None: ... 
	def setFrame(self, id: int, newFrame: float) -> None: ... 
	def sortFrames(self) -> None: ... 
	def getActiveList(self) -> List[Tuple[float,bool]]: ... 


class TimelineAudioInstance():
	assetID: int 
	volume: float 
	pitch: float 
	start: float 
	end: float 


class TimelinePlayer():
	timeline: AssetHandler[Timeline] 
	frame: float 
	loop: bool 
	loops: int 
	playWhenPaused: bool 
	def __init__(self, _timeline: Timeline = None): ... 
	def isActive(self) -> bool: ... 
	def isFinished(self) -> bool: ... 
	def update(self, scene: Scene) -> None: ... 


class AnimationFilter():
	defaultBlend: float 
	blend: Dict[str,float] 
	def __init__(self, _defaultBlend: float = 0): ... 
	def __init__(self, other: AnimationFilter): ... 
	def setToBone(self, bone: Bone, value: float, recursive: bool = False) -> None: ... 
	def getBlend(self, boneName: str) -> float: ... 


class AnimationComponent(Component):
	"""
	Used to animate a Mesh, given an Armature and an Animation. It supports animation blending, filtering and multiple stacked layers of concurrent animations being played and interpolated together.

Requires a valid Mesh Component in order to work properly.
	"""

	armature: AssetHandler[Armature] 
	defaultAnimation: AssetHandler[Animation] 
	armatureBlock: ArmatureUBO 
	def __init__(self): ... 
	def __init__(self, other: AnimationComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def updateSockets(self) -> None: ... 
	def getBoundingBox(self) -> Transform: ... 
	def getAABB(self) -> Tuple[Vector3,Vector3]: ... 
	def playByName(self, anim: str, blend: float = 0, layer: int = 0, loop: bool = False, priority: int = 0) -> AnimationComponent.AnimationLayer: ... 
	def play(self, anim: Animation, blend: float = 0, layer: int = 0, loop: bool = False, priority: int = 0) -> AnimationComponent.AnimationLayer: ... 
	def getAnimation(self, layer: int = 0) -> AnimationComponent.AnimationLayer: ... 
	def getAnimationName(self, layer: int = 0) -> str: ... 
	def setLayerWeight(self, layer: int, value: float) -> None: ... 
	def getLayerWeight(self, layer: int) -> float: ... 
	def createLayerFilter(self, layer: int) -> AnimationFilter: ... 
	def copyLayerFilter(self, filter: AnimationFilter, layer: int) -> AnimationFilter: ... 
	def getLayerFilter(self, layer: int) -> AnimationFilter: ... 
	def removeLayerFilter(self, layer: int) -> None: ... 
	def stop(self, layer: int = 0) -> None: ... 
	def isAnyAnimationBeingPlayed(self) -> bool: ... 
	def isLayerBlending(self, layer: int = 0) -> bool: ... 
	def getBlendingProgress(self, layer: int = 0) -> float: ... 
	def getRootMotion(self) -> Vector3: ... 
	def getRootMotionLayer(self, layer: int = 0) -> Vector3: ... 
	def addPostEvaluationCallback(self, function: Any) -> None: ... # Adds a function pointer to be called after the Animation Component evaluates the Armature pose.
	def clearPostEvaluationCallback(self) -> None: ... 


class AnimationComponentAnimationLayer():
	anim: AssetHandler[Animation] 
	frameCallbacks: List[int] 
	loop: bool 
	priority: int 
	loops: int 
	frame: float 
	speed: float 
	start: float 
	end: float 
	blendTimer: float 
	blendDuration: float 
	rootMotion: Vector3 
	rootMotionLastPos: Vector3 
	rootMotionLastLoopCount: int 
	rootMotionSkip: bool 
	def getName(self) -> str: ... 
	def getProgress(self) -> float: ... 


class AnimationSocketComponent(Component):
	"""
	You can use this Component to copy a given Armature Bone's transform. It will attempt to copy that from its parent Entity.
	"""

	boneName: str 
	position: AnimationSocketComponentCopyInfo 
	rotation: AnimationSocketComponentCopyInfo 
	scale: AnimationSocketComponentCopyInfo 
	def __init__(self): ... 
	def __init__(self, other: AnimationSocketComponent): ... 


class AnimationSocketComponentCopyInfo():
	copy: bool 
	offset: Vector3 


class CameraComponent(Component):
	"""
	This Component, if enabled, will assign its current Transform and Settings to the main Scene Camera.
	"""

	fov: float 
	clipStart: float 
	clipEnd: float 
	lerpPosition: float 
	lerpRotation: float 
	lerpFov: float 
	useCamera: bool 
	isPerspective: bool 
	updateWhenPaused: bool 
	flipX: bool 
	flipY: bool 
	def __init__(self): ... 
	def __init__(self, other: CameraComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def cameraUpdate(self) -> None: ... 
	def updateCamera(self, cam: Camera, applyLerp: bool = True) -> None: ... 
	def renderToTexture(self, textureName: str) -> None: ... 


class LightComponent(Component):
	"""
	Provides Point Light Settings to light the scene.
	"""

	color: Vector3 
	radius: float 
	intensity: float 
	spotAngle: float 
	spotFalloff: float 
	def __init__(self): ... 
	def __init__(self, other: LightComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 


class LogicBricksComponent(Component):
	def __init__(self): ... 
	def __init__(self, other: LogicBricksComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def update(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 


class MeshComponent(Component):
	"""
	The Mesh Component is the main renderable in the Engine.
If you want to render anything into the world, that's probably the component you want.
It takes a Mesh, a Material and a Tint Color (optional) to render.
	"""

	visible: bool 
	proxyForShadowPass: MeshProxyComponent 
	proxyForRegularPass: MeshProxyComponent 
	tint: Vector4 
	mesh: AssetHandler[Mesh] 
	material: AssetHandler[Material] 
	allowUniformOverrides: bool 
	uniformOverrides: dict 
	def __init__(self): ... 
	def __init__(self, other: MeshComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getCustomName(self) -> str: ... 
	def getBoundingBox(self, keepAspect: bool = True) -> Transform: ... 
	def isAlphaBlend(self) -> bool: ... 
	def isOpaque(self) -> bool: ... 
	def getFinalMaterial(self) -> Material: ... 


class MeshProxyComponent(MeshComponent):
	"""
	Creates a Proxy Mesh from a given set of Mesh Components (experimental).
This is meant to be used as an Optimization method for heavy scenes with a lot of small objects that can be batched together when being rendered from a distance to reduce draw calls.
	"""


	# Enum: MeshProxyComponentPassMask:# "MeshProxyComponent" class Enumeration.
	ALL_PASSES : int 
	SHADOW_PASS : int 
	REGULAR_PASS : int 

	settings: MeshProxyComponentProxyMeshSettings 
	def __init__(self): ... 
	def __init__(self, other: MeshProxyComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getCustomName(self) -> str: ... 
	def updateProxies(self, view: Camera, passMask: MeshProxyComponent.PassMask = MeshProxyComponent.PassMask.REGULAR_PASS) -> None: ... 
	def bakeProxyMesh(self) -> None: ... 
	def exportMeshesToBakeAsObj(self) -> None: ... 


class MeshProxyComponentProxyMeshSettings():
	proxyDistance: float 
	decimation: float 
	removeDoubles: bool 
	ignoreUVs: bool 
	passFilter: PassMask 
	skipDynamicRbs: bool 
	skipPythonCmps: bool 
	skipTemplates: bool 
	materialFilter: AssetHandler[Material] 
	useHighestLOD: bool 


class ParticleInstance():
	life: float 
	cycles: int 
	transform: NodeTransform 
	linearVelocity: Vector3 
	angularVelocity: Vector3 


class ParticleComponent(MeshComponent):
	"""
	Renders Particles to the Scene.
	"""

	optimization: ParticleComponentOptimizations 
	instanceSetting: ParticleComponentParticleInstanceDescriptor 
	instanceLifeColors: ParticleComponentCurveColors 
	instanceSpawn: AssetHandler[Mesh] 
	emmiterLifetime: SceneTimer 
	def __init__(self): ... 
	def __init__(self, other: ParticleComponent): ... 
	def getCustomName(self) -> str: ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getParticleCount(self) -> int: ... 
	def getTransforms(self) -> List[Transform]: ... 
	def getTints(self) -> List[Vector4]: ... 


class ParticleComponentOptimizations():
	cullDistance: float 
	frameSkips: int 


class ParticleComponentParticleInstanceDescriptor():
	count: int 
	spawnArea: Vector3 
	scaleMin: Vector3 
	scaleMax: Vector3 
	rotationMin: Vector3 
	rotationMax: Vector3 
	isDynamic: bool 
	useParent: bool 
	life: float 
	respawn: float 
	gravity: Vector3 
	linearVelocity: Vector3 
	linearConservation: Vector3 
	angularVelocity: Vector3 
	angularConservation: Vector3 


class ParticleComponentCurveColors():
	r: Curve 
	g: Curve 
	b: Curve 
	a: Curve 


class PythonCodeComponent(Component):
	"""
	The Python Code Component allows you to write small python code snippets for local usage.
It's similar to the PythonComponent, except that you don't have to create an entire class (it handles that for you).
The downside is that it's not as reusable as the PythonComponent.
	"""


	# Enum: PythonCodeComponentOptimizationPolicy:# "PythonCodeComponent" class Enumeration.
	NO_OPTIMIZATION : int 
	DISTANCE_CULLING : int 
	FRAME_SKIPPING : int 

	optimization: PythonCodeComponentOptimizations 
	code: PythonCodeComponentPyCodes 
	properties: dict 
	def __init__(self): ... 
	def __init__(self, other: PythonCodeComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def update(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def compileScripts(self) -> None: ... 


class PythonCodeComponentOptimizations():
	policy: OptimizationPolicy 
	cullDistance: float 
	executionInterval: float 
	executionTimer: Timer 
	applyToUpdate: bool 
	applyToPausedUpdate: bool 
	applyToEditorUpdate: bool 


class PythonCodeComponentPyCodes():
	pass


class PythonComponent(Component):
	"""
	Main Python Component class. Allows you to create your own custom components (in Python).
Notice that this is a wrapper to your components and you should NOT inherit from this when writting them (inherit from cave.Component instead).
	"""

	def __init__(self): ... 
	def __init__(self, other: PythonComponent): ... 
	def getCustomName(self) -> str: ... 
	def start(self, s: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def update(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getCastedPy(self) -> Component: ... 
	def getClassName(self) -> str: ... 


class TerrainChunk(MeshComponent):
	"""
	Component Class used internally by the Terrain Component to render the diffent Chunks (Components) that composes the actual Terrain. You should not have to worry about this yourself.
	"""

	scale: Vector3 
	offset: Vector3 
	scaleUV: Vector2 
	offsetUV: Vector2 
	owner: TerrainComponent 
	def use(self, shader: ShaderProgram) -> None: ... 
	def getTransform(self) -> Transform: ... 
	def getMatrix(self) -> Matrix4: ... 


class TerrainComponent(Component):
	"""
	This Component handles Terrain Rendering and Physics based on a Height Map.
	"""

	height: float 
	lodRate: float 
	heightMap: AssetHandler[Texture] 
	material: AssetHandler[Material] 
	gridSize: int 
	numComponents: int 
	physicsEnabled: bool 
	physicsGroup: BitMask 
	def __init__(self): ... 
	def __init__(self, other: TerrainComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getBoundingBox(self) -> Transform: ... 
	def generateHeightMap(self, flatTerrain: bool = False, reload: bool = True) -> None: ... 


class TransformComponent(Component, NodeTransform):
	"""
	Transform class that contains Position, Rotation and Scaling information to a given Entity. It also handles parenting system.
	"""

	def __init__(self): ... 
	def __init__(self, other: TransformComponent): ... 
	def getParent(self) -> NodeTransform: ... 


class FirstPersonCamComponent(MouselookComponent):
	def __init__(self): ... 
	def __init__(self, other: FirstPersonCamComponent): ... 
	def start(self, scene: Scene) -> None: ... 


class ThirdPersonCamComponent(Component):

	# Enum: ThirdPersonCamComponentAlignPlayerRule:# "ThirdPersonCamComponent" class Enumeration.
	NEVER : int 
	ON_MOVEMENT : int 
	ALWAYS : int 

	mouselook: ThirdPersonCamComponentMouselook 
	alignPlayer: AlignPlayerRule 
	alignSmooth: float 
	headOffset: Vector3 
	cameraOffset: Transform 
	camCollision: ThirdPersonCamComponentCamCollisionConfig 
	def __init__(self): ... 
	def __init__(self, other: ThirdPersonCamComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def enableJoystick(self, id: int, tolerance: float = 0.1, sensitivity: Vector2 = Vector2(-0.1,0.1)) -> None: ... 
	def disableJoystick(self) -> None: ... 
	def isJoystickEnabled(self) -> bool: ... 


class ThirdPersonCamComponentMouselook():
	sensitivity: Vector2 
	threshold: Vector2 
	pitchLimit: Vector2 


class ThirdPersonCamComponentCamCollisionConfig():
	use: bool 
	radius: float 
	mask: BitMask 


class TopDownCamComponent(Component):
	playerName: str 
	height: float 
	distance: float 
	onGroundOnly: bool 
	forwardAdvance: float 
	def __init__(self): ... 
	def __init__(self, other: TopDownCamComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def getTargetPosition(self) -> Vector3: ... 
	def getExpectedCamPositionFor(self, playerPos: Vector3) -> Vector3: ... 


class AudioComponent(Component):
	"""
	Simplest way to execute Static and Constant audio. Ideal for things such as Ambient sounds, etc.
	"""

	def __init__(self): ... 
	def __init__(self, other: AudioComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 


class MouselookAxisConfig():
	use: bool 
	rotationLocal: bool 
	rotationAxis: int 
	rangeMin: float 
	rangeMax: float 
	sensitivity: float 
	threshold: float 
	m_allowRotationAdjust: bool 


class MouselookComponent(Component):
	"""
	Provides a simple Mouselook implementation to your Entity.
	"""

	lockMousePos: bool 
	xAxis: MouselookAxisConfig 
	yAxis: MouselookAxisConfig 
	def __init__(self): ... 
	def __init__(self, other: MouselookComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 


class PlayerComponent(Component):
	"""
	Provides a basic Player Controller component. Given a Character Component, moves it with W,A,S,D and jumps with Space (optionally).
If you need more control, consider writting your own controller in Python.
	"""

	active: bool 
	smoothTurn: float 
	smoothSpeed: float 
	walkSpeed: float 
	runSpeed: float 
	localMovement: bool 
	jump: bool 
	def __init__(self): ... 
	def __init__(self, other: PlayerComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def isWalking(self) -> bool: ... 
	def isRunning(self) -> bool: ... 


class VehicleControllerComponent(Component):
	active: bool 
	def __init__(self): ... 
	def __init__(self, other: VehicleControllerComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 


class UIElementComponent(Component):
	"""
	Cave's User Interface (UI) Element. This is meant to be renderer to de screen as an UI in order to create texts, boxes, images, buttons or any other element you want.
It also handles anchoring and PARENTING for you, meaning that it will take parent UIElements into account and will affect child ones.
	"""


	# Enum: UIElementComponentStatus:# "UIElementComponent" class Enumeration.
	NORMAL : int 
	HOVERED : int 
	PRESSED : int 

	position: UIVector 
	scale: UIVector 
	layer: int 
	scissor: bool # If enabled, it will limit the Child Elements Rendering region to this UI Element's bounding area.
	quad: UIElementComponentQuadDesc 
	font: UIElementComponentFontDesc 
	text: str 
	defaultQuadAlpha: float 
	defaultQuadColor: Vector3 
	defaultQuadBlurBackground: float 
	def __init__(self): ... 
	def __init__(self, other: UIElementComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getParent(self) -> UIElementComponent: ... 
	def getChildren(self) -> List[UIElementComponent]: ... 
	def getText(self) -> str: ... 
	def setText(self, value: str) -> None: ... 
	def isHovered(self) -> bool: ... 
	def isPressed(self) -> bool: ... 
	def getDrawFontScale(self) -> Vector2: ... 
	def getDefaultQuadAlpha(self) -> float: ... 
	def setDefaultQuadAlpha(self, value: float) -> None: ... 
	def getDefaultQuadColor(self) -> Vector3: ... 
	def setDefaultQuadColor(self, color: Vector3) -> None: ... 
	def getDefaultQuadBlurBackground(self) -> float: ... 
	def setDefaultQuadBlurBackground(self, value: float) -> None: ... 


class UIElementComponentQuadDesc():
	style: UIStyle 
	styleOverride: AssetHandler[UIStyle] 
	hoverable: bool 
	clickable: bool 


class UIElementComponentFontConfig():
	color: Vector4 
	scale: float 
	spacing: float 
	hScale: float 
	lineHeight: float 
	textAlign: int 
	textAnchor: int 


class UIElementComponentFontDesc():
	source: AssetHandler[Font] 
	config: FontConfig 
	text: str 


class CharacterComponent(Component):
	"""
	Provides a basic but functional Character Physics behaviour for you to use.
Ideal for your Player, Enemies, NPCs and other character-like entities.
	"""

	shape: CharacterComponentShapeDesc 
	config: CharacterComponentConfig 
	gravityDirection: Vector3 # The direction of the Gravity. This vector is internally normalized for you before being applied. If the length is zero, it will cause the Character to have no Gravity. If you modify this after the Component initialization, remember to call updateGravity() after to apply the changes.
	group: BitMask 
	mask: BitMask 
	verticalVelocity: float 
	fallSpeed: float 
	gravity: float 
	jumpSpeed: float 
	maxSlope: float 
	enabled: bool 
	def __init__(self): ... 
	def __init__(self, other: CharacterComponent): ... 
	def getVerticalVelocity(self) -> float: ... 
	def setVerticalVelocity(self, val: float) -> None: ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getCollisions(self) -> List[CollisionInfo]: ... # Returns a list with all the collision between the owning Entity and others. It could contain multiple collisions between the same Entities.
	def getCollisionsWith(self, tag: str) -> List[CollisionInfo]: ... # Returns a list with all the collision between the owning Entity and others that contains the given tag. It could contain multiple collisions between the same Entities.
	def collidedWith(self, tag: str) -> bool: ... # Returns True if the Character collided with any other Entity in the Scene that contains the given tag.
	def getTransformFromBullet(self) -> None: ... 
	def sendTransformToBullet(self) -> None: ... 
	def getFallSpeed(self) -> float: ... 
	def setFallSpeed(self, value: float) -> None: ... 
	def getCurrentFallSpeed(self) -> float: ... 
	def getGravity(self) -> float: ... 
	def setGravity(self, value: float) -> None: ... 
	def updateGravity(self) -> None: ... # Applies any changes you made to the gravity or gravityDirection to the Character Physics itself. You don't need to call this every frame, only when you update the gravityDirection.
	def getJumpSpeed(self) -> float: ... 
	def setJumpSpeed(self, value: float) -> None: ... 
	def getMaxSlope(self) -> float: ... 
	def setMaxSlope(self, value: float) -> None: ... 
	def jump(self) -> None: ... 
	def setWalkDirection(self, x: float, y: float, z: float, local: bool = True) -> None: ... 
	def setWalkDirection(self, dir: Vector3, local: bool = True) -> None: ... 
	def getWalkDirection(self, ignoreDeltaTime: bool = False) -> Vector3: ... 
	def getMoveSpeed(self, ignoreDeltaTime: bool = False) -> float: ... 
	def isMoving(self) -> bool: ... 
	def isFalling(self) -> bool: ... 
	def onGround(self) -> bool: ... 
	def reset(self) -> None: ... 
	def isEnabled(self) -> bool: ... 
	def enable(self) -> None: ... 
	def disable(self) -> None: ... 
	def setEnabled(self, value: bool) -> None: ... 
	def getEnabled(self) -> bool: ... 
	def getGravityVector(self) -> Vector3: ... # Returns the gravity direction and force added together (as the length of the vector).


class CharacterComponentShapeDesc():
	"""
	This class is a Descriptor for the Character Component's Shape.
	"""

	height: float # Character's Height, in meters.
	radius: float # Character Collder's Radius, in meters.
	offset: Vector3 # The Collider's offset from the center of the Character Component.


class CharacterComponentConfig():
	fallSpeed: float 
	gravity: float 
	jumpSpeed: float 
	jumpHeight: float 
	maxSlope: float 



# Enum: PhysicsConstraintType: 
HINGE : int 
SLIDER : int 
SPHERE : int 

class PhysicsConstraintComponent(Component):
	def __init__(self): ... 
	def __init__(self, other: PhysicsConstraintComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def setType(self, type: PhysicsConstraintType) -> None: ... 



# Enum: RigidBodyShape: 
CONVEX_HULL : int 
TRIANGLE_MESH : int 
BOUNDING_BOX : int 

class RigidBodyComponent(Component):
	"""
	General Purpose Physics Component. It can be used for Static (non movable) or Dynamic (movable) Entities.
It handles Gravity, collision detection and resolution and so on.
	"""

	mesh: AssetHandler[Mesh] 
	alwaysActive: bool 
	enableDistanceCulling: bool 
	cullDistance: float 
	group: BitMask 
	mask: BitMask 
	angularFactor: Vector3 
	shapeType: RigidBodyShape 
	ghost: bool 
	def __init__(self): ... 
	def __init__(self, other: RigidBodyComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getCollisions(self) -> List[CollisionInfo]: ... # Returns a list with all the collision between the owning Entity and others. It could contain multiple collisions between the same Entities.
	def getCollisionsWith(self, tag: str) -> List[CollisionInfo]: ... # Returns a list with all the collision between the owning Entity and others that contains the given tag. It could contain multiple collisions between the same Entities.
	def collidedWith(self, tag: str) -> bool: ... # Returns True if the Rigid Body collided with any other Entity in the Scene that contains the given tag.
	def getCustomName(self) -> str: ... 
	def getTransformFromBullet(self) -> None: ... 
	def sendTransformToBullet(self) -> None: ... 
	def applyTorque(self, x: float, y: float, z: float) -> None: ... 
	def applyForce(self, x: float, y: float, z: float, location: Vector3) -> None: ... 
	def applyImpulse(self, x: float, y: float, z: float, location: Vector3) -> None: ... 
	def setLinearVelocity(self, x: float, y: float, z: float) -> None: ... 
	def getLinearVelocity(self) -> Vector3: ... 
	def setAngularVelocity(self, x: float, y: float, z: float) -> None: ... 
	def getAngularVelocity(self) -> Vector3: ... 
	def setMass(self, mass: float) -> None: ... # A Static (non movable) body have ZERO mass. Any value greater than that means that the Body is Dynamic (movable). You can also use this information to toggle between static and dynamic.
	def setAngularFactor(self, value: Vector3) -> None: ... 
	def setAngularFactor(self, x: float, y: float, z: float) -> None: ... 
	def getAngularFactor(self) -> Vector3: ... 
	def setShapeType(self, shape: RigidBodyShape) -> None: ... 
	def getShapeType(self) -> RigidBodyShape: ... 
	def getShapeType(self) -> RigidBodyShape: ... 
	def isDynamic(self) -> bool: ... 
	def isBoxCollider(self) -> bool: ... 
	def getBoxOffset(self) -> Vector3: ... 
	def getBoxScale(self) -> Vector3: ... 
	def isGhost(self) -> bool: ... 
	def getGhost(self) -> bool: ... 
	def setGhost(self, value: bool) -> None: ... 
	def getTriangleMeshTriangleCount(self) -> int: ... 


class VehicleComponent(Component):
	engineForce: VehicleComponentEngine 
	steering: VehicleComponentSteering 
	def __init__(self): ... 
	def __init__(self, other: VehicleComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def accelerate(self, scale: float = 1) -> None: ... 
	def reverse(self, scale: float = 1) -> None: ... 
	def brake(self, scale: float = 1) -> None: ... 
	def brakeRelease(self) -> None: ... 
	def idle(self) -> None: ... 
	def applyForce(self, force: float) -> None: ... 
	def turnLeft(self) -> None: ... 
	def turnRight(self) -> None: ... 
	def turnStraight(self) -> None: ... 


class VehicleComponentEngine():
	acceleration: float 
	reverse: float 
	brake: float 


class VehicleComponentSteering():
	clamp: float 
	increment: float 


class WheelComponent(Component):
	tuning: WheelComponentTuningConfig 
	control: WheelComponentControls 
	dirAxis: int # This axis needs to face the Ground. Default is -Y.
	axleAxis: int # This is the axis where wheel will turn around it. Default is +X.
	suspensionRestLength: float 
	radius: float 
	isFrontWheel: bool # Only front wheels have Steering capabilities.
# If enabled, it will be able to turn.
	def __init__(self): ... 
	def __init__(self, other: WheelComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def getDirection(self) -> Vector3: ... 
	def getAxle(self) -> Vector3: ... 


class WheelComponentTuningConfig():
	suspensionStiffness: float # Defines how stiff or soft the suspension is. Higher values result in a stiffer suspension, providing less movement under load, while lower values give a softer suspension with more bounce.
	suspensionCompression: float # Controls how much the suspension compresses under load or during acceleration/braking. It affects the rate of compression when the vehicle hits bumps or dips.
	suspensionDamping: float # Governs how quickly the suspension returns to its normal position after compression or extension. A higher damping value slows down the suspension’s rebound, providing a more stable ride.
	suspensionTravelCmMax: float # Specifies the maximum distance (in centimeters) the suspension can compress or extend. It limits how far the suspension can move when encountering obstacles or changes in terrain.
	suspensionForceMax: float # Sets the maximum force that the suspension can exert to resist compression or extension. This value prevents the suspension from being overwhelmed by extreme forces.
	frictionSlip: float # Defines the amount of friction between the tires and the ground. Higher values increase grip, while lower values cause more sliding and less traction


class WheelComponentControls():
	hasTraction: bool # If enabled, this Wheel will Spin then the Vehicle applies any Forces.
	hasBrake: bool # If enabled, this Wheel will lock when the Vehicle Brakes.


class LogicBricks(Asset):

	# Enum: LogicBricksException:# "LogicBricks" class Enumeration.
	EXECUTION_OK : int 
	UNKNOWN_ERROR : int 
	INVALID_SELF : int 
	INVALID_PARAM_0 : int 
	INVALID_PARAM_1 : int 
	INVALID_PARAM_2 : int 
	INVALID_PARAM_3 : int 
	INVALID_PARAM_4 : int 
	INVALID_PARAM_5 : int 
	INVALID_PARAM_6 : int 
	INVALID_PARAM_7 : int 
	INVALID_PARAM_8 : int 
	INVALID_PARAM_9 : int 
	INVALID_PARAM_10 : int 

	properties: dict 
	def __init__(self): ... 
	def runEvent(self, entity: Entity, eventName: str) -> None: ... 
	def getCurrentEntity(self) -> Entity: ... 
	def newBrick(self, brickName: str) -> LogicBricks.Brick: ... 


class LogicBricksLink():
	owner: Brick 
	id: int 
	typeId: int 
	name: str 
	defaultValue: List[int] 


class LogicBricksBrick():
	id: int 
	className: str 
	name: str 
	position: Vector2 
	hasFlowInput: bool 
	hasFlowOutput: bool 
	inputs: List[LogicBricks.Link] 
	outputs: List[LogicBricks.Link] 
	debug: LogicBricksBrick_DebugBrick 
	def isAction(self) -> bool: ... 


class PythonScript(Asset):
	code: str 
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def compile(self) -> None: ... 
	def run(self, locals: PyObject = None) -> None: ... 
	def compileAndRun(self, locals: PyObject = None) -> None: ... 
	def isCompiled(self) -> bool: ... 
	def getInspection(self) -> List[PyClass]: ... 
	def syncAllOverrides(self, className: str, overrides: dict) -> None: ... 
	def getCode(self) -> str: ... 
	def setCode(self, code: str) -> None: ... 


class BitMask():
	def __init__(self, enableFirstEight: bool = True): ... 
	def __init__(self, other: BitMask): ... 
	def intersect(self, other: BitMask) -> bool: ... 
	def isEnabled(self, n: int) -> bool: ... 
	def get(self, n: int) -> bool: ... 
	def set(self, n: int, value: bool) -> None: ... 
	def enable(self, n: int) -> None: ... 
	def disable(self, n: int) -> None: ... 
	def enableAll(self) -> None: ... 
	def disableAll(self) -> None: ... 
	def getUInt(self) -> int: ... 
	def getFloat(self) -> float: ... 



def lerpVec3Linear(start: Vector3, end: Vector3, amount: float) -> Vector3: ... 
def lerpQuatLinear(start: Quaternion, end: Quaternion, amount: float) -> Quaternion: ... 
def lerpVec3Constant(start: Vector3, end: Vector3, amount: float) -> Vector3: ... 
def lerpQuatConstant(start: Quaternion, end: Quaternion, amount: float) -> Quaternion: ... 

class Curve():
	def __init__(self): ... 
	def __init__(self, other: Curve): ... 
	def setAll(self, value: float) -> None: ... 
	def set(self, value: float) -> None: ... 
	def get(self, position: float) -> float: ... 


class NodeTransform(Transform):
	"""
	Child class from Transform that introduces Parenting to it.
	"""

	worldMatrix: Matrix4 
	worldPosition: Vector3 
	def __init__(self): ... 
	def __init__(self, other: NodeTransform): ... 
	def getWorldMatrix(self) -> Matrix4: ... 
	def getInverseWorldMatrix(self) -> Matrix4: ... 
	def getWorldRotator(self) -> Matrix3: ... 
	def setWorldMatrix(self, matrix: Matrix4) -> None: ... 
	def getWorldPosition(self) -> Vector3: ... 
	def setWorldPosition(self, pos: Vector3) -> None: ... 
	def setWorldPosition(self, x: float, y: float, z: float) -> None: ... 
	def getWorldEuler(self) -> Vector3: ... 
	def getWorldQuaternion(self) -> Quaternion: ... 
	def lookAt(self, direction: Vector3, up: Vector3 = Vector3(0,1,0)) -> None: ... # Rotates the Transform in a way that it faces towards the given Direction, keeping "up" as the up axis.
	def lookAtSmooth(self, direction: Vector3, lerp: float = 0.5, up: Vector3 = Vector3(0,1,0)) -> None: ... # Same as "lookAt", except that it allows you to lerp between the current and the final rotation.
	def setParent(self, parent: NodeTransform, keepTransform: bool = False) -> None: ... 
	def removeParent(self) -> None: ... 
	def getParent(self) -> NodeTransform: ... 
	def addChildren(self, children: NodeTransform) -> None: ... 
	def removeChildren(self, children: NodeTransform) -> None: ... 



def toRadians(degreeAngle: float) -> float: ... 
def toDegrees(radiansAngle: float) -> float: ... 

class Transform():
	"""
	This is the Main Transform class. It uses a VQS system to handle Position, Rotation (in Euler, Quaternion and/or Matrix) and Scale. You can also obtain its model Matrix4 and so on.
	"""

	worldMatrix: Matrix4 # The Transform's world Model Matrix4.
	position: Vector3 # Transform's local Position.
	quaternion: Quaternion # Transform's local Rotation represented as a Quaternion.
	euler: Vector3 # Transform's local Rotation represented in Euler Angles.
	rotator: Matrix3 # Transform's local Rotation represented as a Matrix3.
	scale: Vector3 # Transform's local Scale.
	matrix: Matrix4 # A Matrix4 representing its Local Transform (Model).
	def __init__(self): ... 
	def __init__(self, mat: Matrix4): ... 
	def __init__(self, other: Transform): ... 
	def set(self, other: Transform) -> None: ... 
	def getWorldMatrix(self) -> Matrix4: ... 
	def getInverseWorldMatrix(self) -> Matrix4: ... 
	def getWorldRotator(self) -> Matrix3: ... 
	def setWorldMatrix(self, matrix: Matrix4) -> None: ... 
	def applyTransform(self, other: Transform) -> None: ... # Transforms this using another Transform
	def getWorldPosition(self) -> Vector3: ... 
	def getPosition(self) -> Vector3: ... 
	def setPosition(self, x: float, y: float, z: float) -> None: ... # Sets its Local position to (x, y, z).
	def setPosition(self, position: Vector3) -> None: ... # Sets its Local position to be the provided parameter.
	def getPositionCopy(self) -> Vector3: ... 
	def applyMovement(self, x: float, y: float, z: float) -> None: ... # Applies the (x, y, z) moviment by directly adding it to the Transform's position.
	def applyMovement(self, position: Vector3) -> None: ... # Applies the moviment by directly adding it to the Transform's position.
	def applyLocalMovement(self, x: float, y: float, z: float) -> None: ... # Applies the (x, y, z) moviment while also considering the Transform's rotation.
	def applyLocalMovement(self, movement: Vector3) -> None: ... # Applies the moviment while also considering the Transform's rotation.
	def lookAt(self, direction: Vector3, up: Vector3 = Vector3(0,1,0)) -> None: ... # Rotates the Transform in a way that it faces towards the given Direction, keeping "up" as the up axis.
	def lookAtSmooth(self, direction: Vector3, lerp: float = 0.5, up: Vector3 = Vector3(0,1,0)) -> None: ... # Same as "lookAt", except that it allows you to lerp between the current and the final rotation.
	def lookAtPosition(self, position: Vector3, up: Vector3 = Vector3(0,1,0)) -> None: ... # Rotates the Transform in a way that it faces a Direction towards the given Position, keeping "up" as the up axis.
	def lookAtPositionSmooth(self, position: Vector3, lerp: float = 0.5, up: Vector3 = Vector3(0,1,0)) -> None: ... # Same as "lookAtPosition", except that it allows you to lerp between the current and the final rotation.
	def lerp(self, target: Transform, lerp: float = 0.5) -> None: ... # Lerps a Transform into other by linearly interpolating the Position and Scale and using sLerp for the Rotation (Quaternions).
	def sLerpQuaternion(self, target: Quaternion, lerp: float = 0.5) -> None: ... # Lerps the Transform's Rotation (Quaternion) into another by using sLerp.
	def getQuaternion(self) -> Quaternion: ... 
	def setQuaternion(self, x: float, y: float, z: float, w: float) -> None: ... 
	def setQuaternion(self, quaternion: Quaternion) -> None: ... 
	def getEuler(self) -> Vector3: ... 
	def setEuler(self, x: float, y: float, z: float) -> None: ... 
	def setEuler(self, euler: Vector3) -> None: ... 
	def getRotator(self) -> Matrix3: ... 
	def setRotator(self, rotator: Matrix3) -> None: ... 
	def rotateVector(self, vec: Vector3) -> Vector3: ... 
	def unrotateVector(self, vec: Vector3) -> Vector3: ... 
	def transformVector(self, vec: Vector3) -> Vector3: ... 
	def untransformVector(self, vec: Vector3) -> Vector3: ... 
	def transformDirection(self, dir: Vector3) -> Vector3: ... 
	def untransformDirection(self, dir: Vector3) -> Vector3: ... 
	def getScale(self) -> Vector3: ... 
	def getWorldScale(self) -> Vector3: ... 
	def getScaleCopy(self) -> Vector3: ... 
	def setScale(self, scalar: float) -> None: ... 
	def setScale(self, x: float, y: float, z: float) -> None: ... 
	def setScale(self, scale: Vector3) -> None: ... 
	def getMatrix(self) -> Matrix4: ... 
	def getInverseMatrix(self) -> Matrix4: ... 
	def setMatrix(self, matrix: Matrix4) -> None: ... 
	def getRotationMatrix(self) -> Matrix4: ... 
	def getPitch(self) -> float: ... # The Pitch is the Angle (in Radians) of Rotation of the Transform around its X Axis (Local).
	def getYaw(self) -> float: ... # The Pitch is the Angle (in Radians) of Rotation of the Transform around its Y Axis (Local).
	def getRoll(self) -> float: ... # The Pitch is the Angle (in Radians) of Rotation of the Transform around its Z Axis (Local).
	def getForwardVector(self, world: bool = False) -> Vector3: ... # The vector representing where the Transform's Z Axis is pointed to. If world is True, it will take its parent Transform into account (this is what you probably want in most of the cases).
	def getRightVector(self, world: bool = False) -> Vector3: ... # The vector representing where the Transform's X Axis is pointed to. If world is True, it will take its parent Transform into account (this is what you probably want in most of the cases).
	def getUpVector(self, world: bool = False) -> Vector3: ... # The vector representing where the Transform's Y Axis is pointed to. If world is True, it will take its parent Transform into account (this is what you probably want in most of the cases).
	def move(self, value: Vector3, local: bool = True) -> None: ... 
	def move(self, x: float, y: float, z: float, local: bool = True) -> None: ... 
	def rotate(self, x: float, y: float, z: float) -> None: ... # Rotates the Transform Locally using Radians.
	def rotateEuler(self, x: float, y: float, z: float) -> None: ... # Rotates the Transform Locally using Euler Angles (Degrees).
	def rotateOnAxis(self, radians: float, axis: Vector3) -> None: ... # Rotates the Transform around a given 3D Axis (that can be anything).
	def rotateOnPitch(self, radians: float, world: bool = False) -> None: ... # Rotates the Transform around its X Axis. If world is True, it will take its parent Transform into account.
	def rotateOnYaw(self, radians: float, world: bool = False) -> None: ... # Rotates the Transform around its Y Axis. If world is True, it will take its parent Transform into account.
	def rotateOnRoll(self, radians: float, world: bool = False) -> None: ... # Rotates the Transform around its Z Axis. If world is True, it will take its parent Transform into account.


class CollisionInfo():
	position: Vector3 
	normal: Vector3 
	entity: Entity 


class PhysicsMesh():
	def __init__(self, mesh: Mesh): ... 
	def getPrimitiveInfo(self) -> Transform: ... 
	def getTriangleCount(self) -> int: ... 
	def getMeshOwner(self) -> Mesh: ... 
	def hasMeshOwner(self) -> bool: ... 


class RayCastOut():
	hit: bool 
	position: Vector3 
	normal: Vector3 
	entity: Entity 
	def __init__(self): ... 


class SphereCastOut(RayCastOut):
	penetration: float 
	recoveryPosition: Vector3 
	def __init__(self): ... 


class PhysicsWorld():
	gravity: Vector3 
	def __init__(self): ... 
	def update(self) -> None: ... 
	def drawDebug(self) -> None: ... 
	def rayCast(self, origin: Vector3, target: Vector3, mask: BitMask = BitMask()) -> RayCastOut: ... 
	def rayCastAll(self, origin: Vector3, target: Vector3, mask: BitMask = BitMask()) -> List[RayCastOut]: ... 
	def sphereCast(self, origin: Vector3, target: Vector3, radius: float, mask: BitMask = BitMask()) -> SphereCastOut: ... 
	def sphereCastEntity(self, ignoreEntity: Entity, origin: Vector3, target: Vector3, radius: float, mask: BitMask = BitMask()) -> SphereCastOut: ... 
	def sphereCastAll(self, origin: Vector3, target: Vector3, radius: float, mask: BitMask = BitMask()) -> List[SphereCastOut]: ... 
	def checkContactBox(self, box: Transform, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... 
	def checkContactSphere(self, box: Transform, radius: float, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... 
	def addRigidBody(self, body: RigidBodyComponent) -> None: ... 
	def removeRigidBody(self, body: RigidBodyComponent) -> None: ... 
	def addTerrain(self, body: TerrainComponent) -> None: ... 
	def removeTerrain(self, body: TerrainComponent) -> None: ... 
	def addConstraint(self, constraint: PhysicsConstraintComponent) -> None: ... 
	def removeConstraint(self, constraint: PhysicsConstraintComponent) -> None: ... 
	def addCharacter(self, character: CharacterComponent) -> None: ... 
	def removeCharacter(self, character: CharacterComponent) -> None: ... 
	def getGravity(self) -> Vector3: ... 
	def setGravity(self, gravity: Vector3) -> None: ... 
	def getCollisionsWith(self, body: RigidBodyComponent) -> List[CollisionInfo]: ... 
	def getCollisionsWith(self, body: CharacterComponent) -> List[CollisionInfo]: ... 
	def getDebugInfo(self) -> PhysicsWorld.PhysicsWorldDebugInfo: ... 


class PhysicsWorldPhysicsWorldDebugInfo():
	numBodies: int 
	ghostBodies: int 
	staticBodies: int 
	dynamicBodies: int 
	shapeConvexHull: int 
	shapeBoundingBox: int 
	shapeTriangleMesh: int 
	triangleMeshPolyCount: int 
	triangleMeshEntities: List[Tuple[Entity,int]] 
	numCharacters: int 
	numCollisionObjects: int 
	numConstraints: int 


class App():
	renderer: Renderer 
	gameSettings: AppGameSettings 
	config: AppAppDebugConfig 
	performanceEmulator: AppPerformanceEmulator 
	debugUI: DebugUI 
	def showLoadingScreen(self) -> None: ... 
	def hideLoadingScreen(self) -> None: ... 
	def isLoadingScreenOn(self) -> bool: ... 
	def run(self) -> None: ... 
	def loadGameAssetsFromDisk(self, separateFiles: bool = True) -> None: ... 
	def reloadGameAssetsFromDisk(self, separateFiles: bool = True) -> None: ... 
	def getDeltaTime(self) -> float: ... 
	def getFPS(self) -> int: ... 
	def restartCurrentScene(self) -> None: ... 
	def setScene(self, scene: Scene, forceDirty: bool = False) -> None: ... 
	def setSceneQueued(self, scene: Scene) -> None: ... 
	def getScene(self) -> Scene: ... 
	def getAssetData(self) -> AssetData: ... 
	def getEvents(self) -> Events: ... 
	def getWindow(self) -> Window: ... 
	def getPythonEnv(self) -> PythonEnv: ... 
	def getRenderAspect(self) -> float: ... 
	def setGamePath(self, path: str) -> None: ... 
	def getGamePath(self, localPath: str) -> str: ... 
	def getGameName(self) -> str: ... 
	def setDebugUI(self) -> None: ... 
	def setDebugUI(self, ui: DebugUI) -> None: ... 
	def getDebugUI(self) -> DebugUI: ... 
	def getMousePosition(self) -> Vector2: ... 
	def enableGameLogic(self) -> None: ... 
	def disableGameLogic(self) -> None: ... 
	def isGameLogicEnabled(self) -> bool: ... 
	def loadPythonScripts(self) -> None: ... 
	def getCurrentFrameNumber(self) -> int: ... 


class AppGameSettings():
	limitFps: bool 
	fps: int 
	vsync: bool 
	def updateVSync(self) -> None: ... # Changing the vsync variable alone isn't enough to apply the changes, so you need to call this function after it.


class AppAppDebugConfig():
	debugPhysics: bool 
	debugPhysicsConfig: AppAppDebugConfigDebugPhysicsConfig 
	debugLines: bool 
	debugPlaySound: bool 
	debugUseMist: bool 
	debugApplyPostProcessing: bool 
	showGameUI: bool 
	alwaysFocused: bool 


class AppAppDebugConfigDebugPhysicsConfig():
	drawWireframe: bool 
	drawAabb: bool 
	drawFeaturesText: bool 
	drawContactPoints: bool 
	noDeactivation: bool 
	noHelpText: bool 
	drawText: bool 
	profileTimings: bool 
	enableSatComparison: bool 
	disableBulletLCP: bool 
	enableCCD: bool 
	drawConstraints: bool 
	drawConstaintsLimits: bool 
	fastWireframe: bool 
	drawNormals: bool 


class AppPerformanceEmulator():
	active: bool 
	minFrameCostMs: float 
	maxFrameCostMs: float 


class CaveException():
	def __init__(self, message: str, file: str = "", line: int = 0): ... 
	def __init__(self, other: CaveException): ... 
	def what(self, withStackTrace: bool = True) -> str: ... 



def hideConsole() -> None: ... 
def showConsole() -> None: ... 
def isConsoleVisible() -> bool: ... 
def showProgressBar(title: str, maxValue: int = 100) -> None: ... 
def hideProgressBar() -> None: ... 
def updateProgressBar(value: int) -> None: ... 
def incrementProgressBar() -> None: ... 
def incrementProgressBarWith(value: int) -> None: ... 
def getProgressBar() -> Tuple[int,int]: ... 
def setProgressBar(value: int, maxValue: int) -> None: ... 
def showErrorMessage(title: str, body: str) -> None: ... 
def showWarningMessage(title: str, body: str) -> None: ... 
def showInfoMessage(title: str, body: str) -> None: ... 
def showQuestionMessage(title: str, body: str) -> bool: ... 
def notify(title: str, text: str) -> None: ... 
def selectFolder(title: str, defaultPath: str, forcePath: bool = False) -> str: ... 


def revealInExplorer(path: str) -> None: ... 
def open(path: str, mode: str) -> FILE: ... 
def getBasePath() -> str: ... # Returns the base Path of where the application was launched. Could be the Editor path OR the Player path depending if you're on runtime or not.
def getBaseFile() -> str: ... 
def getEditorPath(localPath: str) -> str: ... # Returns the Absolute path from the Editor's location + the localPath you provide.
def getEditorDataPath(localPath: str) -> str: ... # Returns the default path that the Cave Editor uses to serialize common stuff. Plus the localPath you provide.
def getSystemDataPath(localPath: str) -> str: ... # Returns the default recommended OS Path that is typically used to save local user data. On Windows, its %%AppData%%, on Linux, its HOME, etc. Plus the localPath you provide.
def sanitizeFileName(fileName: str) -> str: ... # Removed Special characters (that are not supported in most OS as file names) from the input fileName.
def splitPath(path: str) -> List[str]: ... 
def isFolder(path: str) -> bool: ... 
def join(path: str, file: str) -> str: ... 
def getOSPath(path: str) -> str: ... 
def replaceFileExtension(filePath: str, newExtension: str) -> str: ... 
def getFileExtension(filePath: str) -> str: ... 
def getFileName(filePath: str, withExtension: bool = True) -> str: ... 
def getFileFolderPath(filePath: str) -> str: ... 
def getLastWriteDate(file: str) -> str: ... 
def getLastWriteTime(file: str) -> int: ... 
def countFilesWithExtensionAt(path: str, extension: str) -> int: ... 
def timeToDate(time: int) -> str: ... 
def exists(filePath: str) -> bool: ... 
def createPath(path: str) -> None: ... 
def duplicate(file: str, target: str) -> None: ... 
def getFilesAt(path: str) -> List[str]: ... 
def remove(path: str) -> bool: ... 
def removeAll(path: str) -> bool: ... 
def dumpToMemory(path: str, length: int, useNewOperator: bool = True) -> int: ... 
def read(file: str) -> str: ... 
def write(file: str, text: str) -> None: ... 


# Cave's Logging System intended for basic Game/Code Debugging and console outputting.

def messageToApp(message: str) -> bool: ... # Given the message, outputs it to the Cave's Editor Console. If the game is exported (so there is no Editor), it will not show anything.
def message(title: str, body: str, icon: str = "", supressWhenExported: bool = False) -> None: ... # Allows you to outputs a given message to Cave's Editor Console but with more control over it, such as the message Title and if you want to supress it in the exported game or not. If you choose to NOT supress, it will show in the Exported game as an Info Modal (using the OS's api).
def fileLogInit() -> None: ... # Enables File Logging (to write logs to a File instead of the Console).
def fileLogShutdown() -> None: ... # Disables File Logging.
def fileLogEnableGlCallback() -> None: ... 
def fileLogMessage(message: str) -> None: ... # Logs a message into the fileLog.txt log file. If file logging is disabled, it will output the message to the Editor's console instead.

class ProgressBar():
	def __init__(self, title: str, maxValue: int = 100, hidden: bool = False): ... 
	def update(self, progress: int) -> None: ... 
	def increment(self) -> None: ... 
	def add(self, value: int) -> None: ... 
	def set(self, value: int, maxValue: int) -> None: ... 
	def getValue(self) -> int: ... 
	def getValueMax(self) -> int: ... 


class ThreadPool():
	def __init__(self, numThreads: int): ... 
	def __init__(self, other: ThreadPool): ... 
	def enqueue(self, task: ThreadPool.Task) -> None: ... 
	def waitAll(self) -> None: ... 
	def getThreadCount(self) -> int: ... 


class Version():
	major: int 
	minor: int 
	patch: int 
	pro: bool 
	def __init__(self): ... 
	def __init__(self, major: int, minor: int, patch: int): ... 
	def __init__(self, other: Version): ... 
	def getVersionStr(self) -> str: ... 
	def isCompatible(self, other: Version, breakPath: bool = False) -> bool: ... 
	def __eq__(self, other) -> bool: ... # self == other
	def __gt__(self, other) -> bool: ... # self > other
	def __lt__(self, other) -> bool: ... # self < other
	def __ge__(self, other) -> bool: ... # self >= other
	def __le__(self, other) -> bool: ... # self <= other


class Window():

	# Enum: WindowType:# "Window" class Enumeration.
	CUSTOM : int 
	MAXIMIZED : int 
	FULLSCREEN : int 

	title: str 
	def setTitle(self, title: str) -> None: ... # Changes the Window title.
	def getTitle(self) -> str: ... # Returns the window Title
	def getAspect(self) -> float: ... 
	def getDisplayIndex(self) -> int: ... 
	def getWindowPosition(self) -> Vector2: ... 
	def getWindowSize(self) -> Vector2: ... 
	def setMousePosition(self, x: int, y: int) -> None: ... 
	def setMousePositionX(self, value: int) -> None: ... 
	def setMousePositionY(self, value: int) -> None: ... 
	def getMousePosition(self, normalize: bool = False) -> Vector2: ... 
	def setFullscreen(self, value: bool) -> None: ... 
	def toggleFullscreen(self) -> None: ... 
	def isFullscreen(self) -> bool: ... 
	def isMaximized(self) -> bool: ... 
	def isMinimized(self) -> bool: ... 
	def hasInputFocus(self) -> bool: ... 
	def hasMouseFocus(self) -> bool: ... 
	def isShown(self) -> bool: ... 
	def isHidden(self) -> bool: ... 
	def minimize(self) -> None: ... 
	def maximize(self) -> None: ... 
	def restore(self) -> None: ... 
	def hide(self) -> None: ... 
	def show(self) -> None: ... 


class File():

	# Enum: FileFileMode:# "File" class Enumeration.
	READ : int 
	WRITE : int 

	asProjectFile: bool 
	seek: int 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def getPath(self) -> str: ... 
	def isValid(self) -> bool: ... 
	def getHeader(self) -> Version: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def read(self, buffer: str) -> bool: ... 
	def write(self, buffer: str) -> bool: ... 
	def read(self, src: SourceCode) -> bool: ... 
	def write(self, src: SourceCode) -> bool: ... 
	def readStr(self, buffer: str) -> bool: ... 
	def writeStr(self, buffer: str) -> bool: ... 


class FileBinary(File):
	seek: int 
	def __init__(self, fileName: str, mode: File.FileMode, throwIncompatibility: bool = True): ... 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 


class FileJson(File):
	seek: int 
	def __init__(self, fileName: str, mode: File.FileMode): ... 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def readStr(self, buffer: str) -> bool: ... 
	def writeStr(self, buffer: str) -> bool: ... 


class FileVirtual(File):
	seek: int 
	def __init__(self, mode: File.FileMode, throwIncompatibility: bool = True, header: bool = True, initialBufferSize: int = 4096): ... 
	def __init__(self, buffer: None, bufferSize: int): ... 
	def __init__(self, other: FileVirtual): ... 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def resetMode(self, mode: File.FileMode) -> bool: ... 
	def getUsedSize(self) -> int: ... 


class SceneTimer(Timer):
	"""
	Scene Timer class. Inherits from the Timer class and have the same behavior, except that it won't increment time while the Scene is paused. That's probably the timer you want to use in most cases.
	"""

	def __init__(self): ... 
	def __init__(self, start: float): ... 


class TimedLerp():
	"""
	This class lerps, in a given time in seconds, one value (current) to another (destination). After the lerp is finished, it will always return the destination value.
	"""

	def __init__(self, current: float = 0, destination: float = 1, durationInSeconds: float = 1): ... 
	def __init__(self, other: TimedLerp): ... 
	def get(self) -> float: ... 
	def set(self, current: float, destination: float = 1, durationInSeconds: float = 1) -> None: ... 
	def isFinished(self) -> bool: ... # Checks if the class has finished the lerping process.


class Timer():
	"""
	Timer class that counts elapsed time in seconds. Keep in mind that it keeps counting time even if the scene is paused. If you don't want that, check the SceneTimer instead.
	"""

	def __init__(self): ... 
	def __init__(self, start: float): ... 
	def get(self) -> float: ... # Gets the elapsed time in seconds.
	def set(self, value: float) -> None: ... # Sets the elapsed time to a given amount of seconds and continues to count from that point.
	def reset(self) -> None: ... # Resets the elapsed time to zero and starts counting again.


