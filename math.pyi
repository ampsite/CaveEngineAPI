# Python Stub File for the Cave Engine's MATH API
# The code here is available at cave.math. submodule

from typing import List, Dict, Tuple

import cave

def clamp(x: float, minVal: float, maxVal: float) -> float: ...

def min(x: float, y: float) -> float: ...
def max(x: float, y: float) -> float: ...

def sin(value: float) -> float: ...
def cos(value: float) -> float: ...
def tan(value: float) -> float: ...

def asin(value: float) -> float: ...
def acos(value: float) -> float: ...
def atan(value: float) -> float: ...

def abs(value: float) -> float: ...
def ceil(value: float) -> float: ...
def floor(value: float) -> float: ...
def round(value: float) -> float: ...

def pow(x: float, y: float) -> float: ...

def toEuler(radians: float) -> float: ...   # Converts Radians to Euler Angles
def toDegrees(radians: float) -> float: ... # Converts Radians to Euler Angles (same as toEuler)
def toRadians(euler: float) -> float: ...   # Converts Euler Angles to Radians

# Regular Lerpings:
def lerp(a: float, b: float, value: float) -> float: ...
def lerp(a: Vector2, b: Vector2, value: float) -> Vector2: ...
def lerp(a: Vector3, b: Vector3, value: float) -> Vector3: ...
def lerp(a: Vector4, b: Vector4, value: float) -> Vector4: ...
def lerp(a: int, b: int, value: float) -> int: ...
def lerp(a: IntVector2, b: IntVector2, value: float) -> IntVector2: ...
def lerp(a: IntVector3, b: IntVector3, value: float) -> IntVector3: ...
def lerp(a: IntVector4, b: IntVector4, value: float) -> IntVector4: ...

# Ease Lerpings:
def lerpEase(a: float, b: float, value: float) -> float: ...
def lerpEase(a: Vector2, b: Vector2, value: float) -> Vector2: ...
def lerpEase(a: Vector3, b: Vector3, value: float) -> Vector3: ...
def lerpEase(a: Vector4, b: Vector4, value: float) -> Vector4: ...
def lerpEase(a: int, b: int, value: float) -> int: ...
def lerpEase(a: IntVector2, b: IntVector2, value: float) -> IntVector2: ...
def lerpEase(a: IntVector3, b: IntVector3, value: float) -> IntVector3: ...
def lerpEase(a: IntVector4, b: IntVector4, value: float) -> IntVector4: ...

# Euler Lerpings:
def lerpEuler(a: Vector3, b: Vector3, value: float) -> Vector3: ...

# Quadric Lerpings:
def lerpQuadric(a: float, b: float, c: float, value: float) -> float: ...
def lerpQuadric(a: Vector2, b: Vector2, c: Vector2, value: float) -> Vector2: ...
def lerpQuadric(a: Vector3, b: Vector3, c: Vector3, value: float) -> Vector3: ...
def lerpQuadric(a: Vector4, b: Vector4, c: Vector4, value: float) -> Vector4: ...
def lerpQuadric(a: int, b: int, c: int, value: float) -> int: ...
def lerpQuadric(a: IntVector2, b: IntVector2, c: IntVector2, value: float) -> IntVector2: ...
def lerpQuadric(a: IntVector3, b: IntVector3, c: IntVector3, value: float) -> IntVector3: ...
def lerpQuadric(a: IntVector4, b: IntVector4, c: IntVector4, value: float) -> IntVector4: ...

# Quaternion Lerpings:
def lerp(a: Quaternion, b: Quaternion, value: float) -> Quaternion: ...
def lerpEase(a: Quaternion, b: Quaternion, value: float) -> Quaternion: ...
def slerp(a: Quaternion, b: Quaternion, value: float) -> Quaternion: ...

def normalizeEulerAngle(angle: float) -> float: ... # Returns the angle in range [0, 360]
def clampEulerAngle(angle: float, fromMin: float, fromMax) -> float: ... # Clamps the euler angle, works with negative eulers too!

def mapRange(value: float, fromMin: float, fromMax: float, toMin: float, toMax: float) -> float: ...

def dot(x: Vector2, y: Vector2) -> float: ...
def dot(x: Vector3, y: Vector3) -> float: ...
def dot(x: Vector4, y: Vector4) -> float: ...

def inverse(q: Quaternion) -> Quaternion: ...
def inverse(m: Matrix4) -> Matrix4: ...

def project(vec: Vector2, other: Vector2) -> Vector2: ...
def project(vec: Vector3, other: Vector3) -> Vector3: ...
def project(vec: Vector4, other: Vector4) -> Vector4: ...

# AABB and Bounding Box:
def getTransformFromAABB(bMin: Vector3, bMax: Vector3) -> cave.Transform: ...
def getMinVector(a: Vector3, b: Vector3) -> Vector3: ...
def getMaxVector(a: Vector3, b: Vector3) -> Vector3: ...

# Intersections:
def intersectLineSphere(lineP1: Vector3, lineP2: Vector3, sphereCenter: Vector3, sphereRadius: float) -> list: ... # Returns a list of tuples containing the intersection positions and normals!
def intersectLineTriangle(lineP1: Vector3, lineP2: Vector3, p1: Vector3, p2: Vector3, p3: Vector3) -> (Vector3, None): ...

def getClosestPointOnTriangle(a: Vector3, b: Vector3, c: Vector3, pos: Vector3) -> Vector3: ...  # Given a pos and a triangle (a,b,c), returns the closest point within this triangle to that given pos.
def getClosestPointBarycentric(a: Vector3, b: Vector3, c: Vector3, pos: Vector3) -> Vector3: ... # Same as the closestPointOnTriangle, except that it returns the Barycentric coordinates to that closest point related to the triangle instead.

def getClosestPointOnLine(a: Vector3, b: Vector3, pos: Vector3) -> Vector3: ... # Given a pos and a line segment (a,b), returns the closest point within this line segment to that given pos.
def getClosestPointOnLineBarycentric(a: Vector3, b: Vector3, pos: Vector3) -> Vector2: ... # Same as getClosestPointOnLine, except that it returns two values with how much of each point (a, b) needs to be added together to result in the closest point.

def projectDirectionOnTrianglePlane(a: Vector3, b: Vector3, c: Vector3, direction: Vector3) -> Vector3: ... #  Projects a direction vector onto the plane of the given triangle.

def getEdgePlaneIntersection(p1: Vector3, p2: Vector3, planePos: Vector3, planeNormal: Vector3) -> Tuple[bool, Vector3]: ...
def getTrianglePlaneIntersection(a: Vector3, b: Vector3, c: Vector3, planePos: Vector3, planeNormal: Vector3) -> Vector3: ...

# Deprecated:
def normalized(vector: Vector3) -> Vector3: ...
def length(vector: Vector3) -> Vector3: ...